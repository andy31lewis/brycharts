__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1623154221976, "brycharts.bryaxes": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom .roundfns import *\nfrom math import isnan,log10\nfrom . import dragcanvas as SVG\nimport browser.svg as svg\n\nclass ScaledObjectMixin():\n def rescale(self,canvas):\n  (x,y)=self.anchorPoint\n  \n  self.attrs[\"transform\"]=f\"translate({x},{y}) scale({canvas.xScaleFactor},{-canvas.yScaleFactor}) translate({-x},{-y})\"\n  \nclass AxesTextObject(SVG.TextObject,ScaledObjectMixin):\n def __init__(self,canvas,string=\"\",anchorpoint=(0,0),anchorposition=1,fontsize=12):\n  super().__init__(string,anchorpoint,anchorposition,fontsize)\n  self.anchorPoint=anchorpoint\n  self.rescale(canvas)\n  \nclass AxesWrappingTextObject(SVG.WrappingTextObject,ScaledObjectMixin):\n def __init__(self,canvas,string=\"\",anchorpoint=(0,0),width=80,anchorposition=2,fontsize=12):\n  super().__init__(canvas,string,anchorpoint,width /canvas.xScaleFactor,anchorposition,fontsize)\n  self.anchorPoint=anchorpoint\n  self.rescale(canvas)\n  \nclass AxesPoint(svg.circle,ScaledObjectMixin):\n def __init__(self,canvas,XY=(0,0),colour=\"black\",objid=None ):\n  (x,y)=XY\n  sf=canvas.scaleFactor\n  svg.circle.__init__(self,cx=x,cy=y,r=3,style={\"stroke\":\"#00000000\",\"stroke-width\":5,\"fill\":colour,\"vector-effect\":\"non-scaling-stroke\"})\n  self.anchorPoint=self.XY=SVG.Point(XY)\n  self.rescale(canvas)\n  if objid:self.id=objid\n  \n def _update(self):\n  pass\n  \nclass Axis(object):\n def __init__(self,Min,Max,label,fontsize=12,\n majorTickInterval=None ,minorTickInterval=None ,scaleInterval=None ,\n showScale=True ,showMajorTicks=True ,showMinorTicks=True ,showMajorGrid=True ,showMinorGrid=True ,\n showArrow=False ,showAxis=True ):\n  self.min=float(Min)\n  self.max=float(Max)\n  self.label=label if label else \"\"\n  self.fontsize=fontsize\n  for argname in self.__init__.__code__.co_varnames[4:]:\n   setattr(self,argname,locals()[argname])\n  self.calculateDefaultTicks(5)\n  self.min=rounddown(Min,self.scaleInterval)\n  self.max=roundup(Max,self.scaleInterval)\n  \n def calculateDefaultTicks(self,mindivs):\n  self.scaleInterval,self.majorTickInterval,self.minorTickInterval=getscaleintervals(self.min,self.max,mindivs)\n  \nclass Ticks(SVG.GroupObject):\n def __init__(self,direction,ticktype,axis,omit=[]):\n  gap=axis.majorTickInterval if ticktype ==\"major\"else axis.minorTickInterval\n  ticklength=axis.tickLength if ticktype ==\"major\"else axis.tickLength /2\n  ticks=[]\n  v=axis.min\n  while v <=axis.max:\n   if v not in omit:\n    if direction ==\"x\":\n     ticks.append(SVG.LineObject([(v,axis.position),(v,axis.position -ticklength)]))\n    else :\n     ticks.append(SVG.LineObject([(axis.position,v),(axis.position -ticklength,v)]))\n   v +=gap\n  super().__init__(ticks)\n  \nclass GridLines(SVG.GroupObject):\n def __init__(self,direction,gridtype,axis,linemin,linemax,omit=[]):\n  gap=axis.majorTickInterval if gridtype ==\"major\"else axis.minorTickInterval\n  linestyle=\"faintdash1\"if gridtype ==\"major\"else \"faintdash2\"\n  gridlines=[]\n  v=axis.min\n  while v <=axis.max:\n   if v not in omit:\n    if direction ==\"x\":\n     gridlines.append(SVG.LineObject([(v,linemin),(v,linemax)],linestyle))\n    else :\n     gridlines.append(SVG.LineObject([(linemin,v),(linemax,v)],linestyle))\n   v +=gap\n  super().__init__(gridlines)\n  \nclass ScaleValues(SVG.GroupObject):\n def __init__(self,canvas,direction,axis,axispos,ticklength,omit=[]):\n  scalevalues=[]\n  v=axis.min\n  while v <=axis.max:\n   r=round(v,6)\n   if r not in omit:\n    n=int(1 -log10(axis.scaleInterval))\n    scalestring=str(int(v))if int(r)==r else f\"{v:.{n}f}\"\n    if direction ==\"x\":\n     scalevalues.append(AxesTextObject(canvas,scalestring,(v,axispos -ticklength),2,fontsize=12))\n    else :\n     scalevalues.append(AxesTextObject(canvas,scalestring,(axispos -ticklength,v),6,fontsize=12))\n   v +=axis.scaleInterval\n  super().__init__(scalevalues)\n  \nclass AxesCanvas(SVG.CanvasObject):\n def __init__(self,parent,width,height,xAxis=None ,yAxis=None ,title=None ,objid=None ):\n  super().__init__(width,height,objid=objid)\n  parent <=self\n  self.attrs[\"preserveAspectRatio\"]=\"none\"\n  self.container=SVG.GroupObject(objid=\"panel\")\n  \n  self.container.attrs[\"transform\"]=\"scale(1,-1)\"\n  self.addObject(self.container)\n  self.mouseMode=SVG.MouseMode.PAN\n  self.lineWidthScaling=False\n  self.title=title\n  self.tooltips=[]\n  self.bind(\"touchstart\",self.clearTooltips)\n  \n  self.drawAxes(xAxis,yAxis)\n  \n def attachObject(self,svgobject):\n  self.container.addObject(svgobject)\n  \n def attachObjects(self,objectlist):\n  for obj in objectlist:\n   if isinstance(obj,(list,tuple)):\n    self.attachObjects(obj)\n   else :\n    self.container.addObject(obj)\n    \n def rescaleObjects(self):\n  print(\"Using bryaxes rescaleObjects\")\n  for obj in self.objectDict.values():\n   if isinstance(obj,ScaledObjectMixin):\n    obj.rescale(self)\n    \n def fitContents(self):\n  super().fitContents()\n  self.rescaleObjects()\n  super().fitContents()\n  \n def clearTooltips(self,event):\n  if event.target !=self:return\n  for tooltip in self.tooltips:tooltip.hide()\n  \n \"\"\"\n    def makeXScaleValue(self, x, y):\n        if param(xAxis,PiScaling)=1:\n            ApproxDecimaltoFraction(x/3.14159,99,FracPi())\n            if FracPi(0)=1:\n                Numerator=\"\"\n            elif FracPi(0)=-1:\n                Numerator=\"-\"\n            else:\n                Numerator=CStr(FracPi(0))\n\n            if FracPi(1)=1:\n                Denominator=\"\"\n            else:\n                Denominator=\"/\" & CStr(FracPi(1))\n                ScaleString=Numerator & \"\u03c0\" & Denominator\n        else:\n    \"\"\"\n \n def drawAxes(self,xAxis,yAxis):\n  if xAxis.max <=xAxis.min or yAxis.max <=yAxis.min:return\n  self.setViewBox([(xAxis.min,-yAxis.max),(xAxis.max,-yAxis.min)])\n  xAxis.tickLength=10 *self.yScaleFactor\n  yAxis.tickLength=10 *self.xScaleFactor\n  xAxis.position=yAxis.min if yAxis.min >0 else yAxis.max if yAxis.max <0 else 0\n  yAxis.position=xAxis.min if xAxis.min >0 else xAxis.max if xAxis.max <0 else 0\n  self.xAxis=xAxis\n  self.yAxis=yAxis\n  self.container.clear()\n  \n  if xAxis.showAxis:\n   self.xAxisObjects=SVG.GroupObject([\n   SVG.LineObject([(xAxis.min,xAxis.position),(xAxis.max,xAxis.position)]),\n   AxesTextObject(self,xAxis.label,(xAxis.max,xAxis.position -xAxis.tickLength -1.5 *xAxis.fontsize *self.yScaleFactor),3,fontsize=xAxis.fontsize)\n   ])\n   if xAxis.showArrow:\n    self.xAxisObjects.addObjects([\n    SVG.LineObject([(xAxis.max,xAxis.position),(xAxis.max -yAxis.tickLength,xAxis.position -xAxis.tickLength)]),\n    SVG.LineObject([(xAxis.max,xAxis.position),(xAxis.max -yAxis.tickLength,xAxis.position+xAxis.tickLength)])\n    ])\n    \n   if xAxis.showMinorTicks and xAxis.minorTickInterval /self.xScaleFactor >5:\n    self.xAxisObjects.addObjects(Ticks(\"x\",\"minor\",xAxis))\n   if xAxis.showMajorTicks:\n    self.xAxisObjects.addObjects(Ticks(\"x\",\"major\",xAxis))\n   if xAxis.showScale:\n    omit=[yAxis.position]if yAxis.showAxis and yAxis.min <xAxis.position else []\n    self.xAxisObjects.addObjects(ScaleValues(self,\"x\",xAxis,xAxis.position,xAxis.tickLength,omit))\n    \n   if xAxis.showMinorGrid and xAxis.minorTickInterval /self.xScaleFactor >5:\n    omit=[yAxis.position]if yAxis.showAxis else []\n    self.xAxisObjects.addObjects(GridLines(\"x\",\"minor\",xAxis,yAxis.min,yAxis.max,omit))\n   if xAxis.showMajorGrid:\n    omit=[yAxis.position]if yAxis.showAxis else []\n    self.xAxisObjects.addObjects(GridLines(\"x\",\"major\",xAxis,yAxis.min,yAxis.max,omit))\n    \n   self.attachObject(self.xAxisObjects)\n   \n  if yAxis.showAxis:\n   self.yAxisObjects=SVG.GroupObject([\n   SVG.LineObject([(yAxis.position,yAxis.min),(yAxis.position,yAxis.max)]),\n   AxesTextObject(self,yAxis.label,(yAxis.position,yAxis.max),7,fontsize=yAxis.fontsize)\n   ])\n   if yAxis.showArrow:\n    self.yAxisObjects.addObjects([\n    SVG.LineObject([(yAxis.position,yAxis.max),(yAxis.position -yAxis.tickLength,yAxis.max -xAxis.tickLength)]),\n    SVG.LineObject([(yAxis.position,yAxis.max),(yAxis.position+yAxis.tickLength,yAxis.max -xAxis.tickLength)])\n    ])\n    \n   if yAxis.showMinorTicks and yAxis.minorTickInterval /self.yScaleFactor >5:\n    self.yAxisObjects.addObjects(Ticks(\"y\",\"minor\",yAxis))\n   if yAxis.showMajorTicks:\n    self.yAxisObjects.addObjects(Ticks(\"y\",\"major\",yAxis))\n   if yAxis.showScale:\n    omit=[xAxis.position]if xAxis.showAxis and xAxis.min <yAxis.position else []\n    self.yAxisObjects.addObjects(ScaleValues(self,\"y\",yAxis,yAxis.position,yAxis.tickLength,omit))\n    \n   if yAxis.showMinorGrid and yAxis.minorTickInterval /self.yScaleFactor >5:\n    omit=[xAxis.position]if xAxis.showAxis else []\n    self.yAxisObjects.addObjects(GridLines(\"y\",\"minor\",yAxis,xAxis.min,xAxis.max,omit))\n   if yAxis.showMajorGrid:\n    omit=[xAxis.position]if xAxis.showAxis else []\n    self.yAxisObjects.addObjects(GridLines(\"y\",\"major\",yAxis,xAxis.min,xAxis.max,omit))\n    \n   self.attachObject(self.yAxisObjects)\n  if self.title:\n   self.attachObject(AxesTextObject(self,self.title,((xAxis.min+xAxis.max)/2,yAxis.max+1.5 *yAxis.fontsize *self.yScaleFactor),8,yAxis.fontsize *1.25))\n  self.fitContents()\n", ["browser.svg", "brycharts", "brycharts.roundfns", "math"]], "brycharts.dragcanvas": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\nimport time\nfrom browser import document,alert,window\nimport browser.svg as svg\nimport browser.html as html\nfrom math import sin,cos,atan2,pi,hypot,floor,log10\nsvgbase=svg.svg(width=0,height=0)\nbasepoint=svgbase.createSVGPoint()\nlasttaptime=0\nMOUSEEVENTS=[\"mousedown\",\"mousemove\",\"mouseup\",\"click\"]\nTOUCHEVENTS=[\"touchstart\",\"touchmove\",\"touchend\"]\n\nclass Enum(list):\n def __init__(self,name,string):\n  values=string.split()\n  for i,value in enumerate(values):\n   setattr(self,value,i)\n   self.append(i)\n   \nMouseMode=Enum('MouseMode','NONE DRAG TRANSFORM DRAW EDIT PAN')\nTransformType=Enum('TransformType','NONE TRANSLATE ROTATE XSTRETCH YSTRETCH ENLARGE')\nPosition=Enum('Position','CONTAINS INSIDE OVERLAPS EQUAL DISJOINT')\n\nclass ObjectMixin(object):\n ''\n \n def cloneObject(self):\n  ''\n\n  \n  if isinstance(self,GroupObject):\n   newobject=self.__class__()\n   for obj in self.objectList:\n    if isinstance(obj,ObjectMixin):\n     newobj=obj.cloneObject()\n     newobject <=newobj\n     newobj.group=newobject\n     newobject.objectList.append(newobj)\n  elif isinstance(self,ObjectMixin):\n   if isinstance(self,ImageObject)and not self.imageloaded:raise RuntimeError(\"ImageObject cannot be cloned until fully loaded\")\n   \n   newobject=self.__class__()\n   for attrname in [\"XY\",\"pointList\",\"pointsetList\",\"angle\",\"fixed\",\"rotatestring\",\"centre\",\"_width\",\"_height\",\n   \"currentAspectRatio\",\"imageWidth\",\"imageHeight\",\"imageAspectRatio\",\"imageloaded\",\n   \"startangle\",\"endangle\",\"radius\"]:\n    attr=getattr(self,attrname,\"NO_SUCH_ATTRIBUTE\")\n    if attr ==\"NO_SUCH_ATTRIBUTE\":continue\n    newattr=list(attr)if isinstance(attr,list)else attr\n    setattr(newobject,attrname,newattr)\n  else :\n   return None\n   \n   \n  for key in self.attrs:\n   value=self.attrs[key]\n   newobject.attrs[key]=value\n  newobject.id=\"\"\n  return newobject\n  \n def setPointList(self,pointlist):\n  ''\n  self.pointList=[Point(coords)for coords in pointlist]\n  if isinstance(self,BezierObject):self.pointsetList=self._getpointsetlist(pointlist)\n  self._update()\n  self._updatehittarget()\n  \n def setStyle(self,attribute,value):\n  ''\n  self.style={attribute:value}\n  \n def _updatehittarget(self):\n  ''\n  hittarget=getattr(self,\"hitTarget\",None )\n  if hittarget:\n   hittarget.pointList=self.pointList\n   if isinstance(self,BezierObject):hittarget.pointsetList=self.pointsetList\n   if isinstance(self,(RectangleObject,EllipseObject,ImageObject,UseObject)):hittarget.angle=self.angle\n   hittarget._update()\n   \n def _transformedpointlist(self,matrix):\n  ''\n  newpointlist=[]\n  for point in self.pointList:\n   (basepoint.x,basepoint.y)=point\n   newpt=basepoint.matrixTransform(matrix)\n   newpointlist.append(Point((newpt.x,newpt.y)))\n  return newpointlist\n  \n def __repr__(self):\n  return f\"{self.__class__}{self.id}\"\n  \nclass SmoothBezierMixin(object):\n ''\n def _calculatecontrolpoints(self,points):\n  ''\n  [(x1,y1),(x2,y2),(x3,y3)]=points\n  (dx1,dy1)=((x2 -x1),(y2 -y1))\n  (dx3,dy3)=((x2 -x3),(y2 -y3))\n  d1=hypot(dx1,dy1)\n  d2=hypot(dx3,dy3)\n  if d1 ==0 or d2 ==0:return ((x2,y2),(x2,y2))\n  cos1,sin1=dx1 /d1,dy1 /d1\n  cos2,sin2=dx3 /d2,dy3 /d2\n  \n  (c1x,c1y)=(x2 -d1 *(cos1 -cos2)/2,y2 -d1 *(sin1 -sin2)/2)\n  (c2x,c2y)=(x2+d2 *(cos1 -cos2)/2,y2+d2 *(sin1 -sin2)/2)\n  c1=((c1x+x2)/2,(c1y+y2)/2)\n  c2=((c2x+x2)/2,(c2y+y2)/2)\n  return (Point(c1),Point(c2))\n  \n '''The following XxxObject classes share various common parameters and attributes.\n    ###Common Parameters\n    When created, as well as the paramters listed for each type of Object, they all share the following optional parameters:\n    `objid`: id of the object (for referencing in the document or using `canvas.getSelectedObject(id)`\n    (The following are not applicable to TextObject, WrappingTextObject, PointObject or UseObject)\n    `linecolour`: colour of the \"stroke\" or outline of the shape\n    `linewidth`: width of the outline of the shape (its \"stroke-width\")\n    `fillcolour`: colour of the interior of the shape (not applicable to LineObject). Use \"none\" if no fill desired.\n\n    ### Common Attributes\n    After creation and adding to the canvas using `canvas.addObject()`, they have following attributes:\n    `obj.fixed` (read/write): If set to `True`, the object cannot be dragged or transformed with the mouse (default `False`)\n    `obj.canvas` (read only): A reference to the canvas which contains the object\n    `obj.pointList` (read only): See individual object definitions for its meaning. (Not applicable to TextObject, WrappingTextObject or PointObject.)\n\n    They also share the following methods:\n    `obj.setPointList()`, `obj.setStyle()`, `obj.cloneObject`\n    '''\nclass LineObject(svg.line,ObjectMixin):\n ''\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],style=\"solid\",linecolour=\"black\",linewidth=1,fillcolour=\"none\",objid=None ):\n  [(x1,y1),(x2,y2)]=pointlist\n  \n  if style ==\"faintdash1\":\n   dasharray=\"10,5\"\n   linecolour=\"grey\"\n  elif style ==\"faintdash2\":\n   dasharray=\"2,2\"\n   linecolour=\"lightgrey\"\n  else :\n   dasharray=None\n   \n  svg.line.__init__(self,x1=x1,y1=y1,x2=x2,y2=y2,style={\"stroke\":linecolour,\"strokeDasharray\":dasharray,\"stroke-width\":linewidth,\"fill\":\"none\"})\n  self.pointList=[Point(coords)for coords in pointlist]\n  if objid:self.id=objid\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  self.attrs[\"x1\"]=x1\n  self.attrs[\"y1\"]=y1\n  self.attrs[\"x2\"]=x2\n  self.attrs[\"y2\"]=y2\n  \nclass TextObject(svg.text,ObjectMixin):\n ''\n\n\n\n\n \n def __init__(self,string=\"\",anchorpoint=(0,0),anchorposition=1,fontsize=12,style=\"normal\",ignorescaling=False ,canvas=None ,objid=None ):\n  (x,y)=anchorpoint\n  stringlist=string.split(\"\\n\")\n  rowcount=len(stringlist)\n  if anchorposition in [3,6,9]:\n   horizpos=\"end\"\n  elif anchorposition in [2,5,8]:\n   horizpos=\"middle\"\n  else :\n   horizpos=\"start\"\n  lineheight=fontsize *1.2\n  if ignorescaling and canvas:\n   fontsize *=canvas.scaleFactor\n   lineheight *=canvas.scaleFactor\n  if anchorposition in [1,2,3]:\n   yoffset=fontsize\n  elif anchorposition in [4,5,6]:\n   yoffset=fontsize -lineheight *rowcount /2\n  else :\n   yoffset=fontsize -lineheight *rowcount\n   \n  svg.text.__init__(self,stringlist[0],x=x,y=y+yoffset,font_size=fontsize,text_anchor=horizpos)\n  for s in stringlist[1:]:\n   self <=svg.tspan(s,x=x,dy=lineheight)\n  if objid:self.id=objid\n  \nclass WrappingTextObject(svg.text):\n ''\n \n def __init__(self,canvas,string,anchorpoint,width,anchorposition=1,fontsize=12,style=\"normal\",ignorescaling=False ,objid=None ):\n  (x,y)=anchorpoint\n  lineheight=fontsize *1.2\n  if ignorescaling:\n   fontsize *=canvas.scaleFactor\n   lineheight *=canvas.scaleFactor\n  words=string.split()\n  svg.text.__init__(self,\"\",x=x,font_size=fontsize)\n  canvas <=self\n  tspan=svg.tspan(words.pop(0),x=x,dy=0)\n  self <=tspan\n  rowcount=1\n  for word in words:\n   tspan.text +=\" \"+word\n   if tspan.getComputedTextLength()>width:\n    tspan.text=tspan.text[:-len(word)-1]\n    tspan=svg.tspan(word,x=x,dy=lineheight)\n    self <=tspan\n    rowcount +=1\n    \n  if anchorposition in [3,6,9]:\n   horizpos=\"end\"\n  elif anchorposition in [2,5,8]:\n   horizpos=\"middle\"\n  else :\n   horizpos=\"start\"\n  self.attrs[\"text-anchor\"]=horizpos\n  if anchorposition in [1,2,3]:\n   yoffset=fontsize\n  elif anchorposition in [4,5,6]:\n   yoffset=fontsize *(1 -rowcount /2)\n  else :\n   yoffset=fontsize *(1 -rowcount)\n  self.attrs[\"y\"]=y+yoffset\n  if objid:self.id=objid\n  \nclass PolylineObject(svg.polyline,ObjectMixin):\n ''\n \n def __init__(self,pointlist=[(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\",objid=None ):\n  svg.polyline.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self.pointList=[Point(coords)for coords in pointlist]\n  self._update()\n  if objid:self.id=objid\n  \n def _update(self):\n  self.attrs[\"points\"]=\" \".join([str(point[0])+\",\"+str(point[1])for point in self.pointList])\n  \nclass PolygonObject(svg.polygon,ObjectMixin):\n ''\n \n def __init__(self,pointlist=[(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  svg.polygon.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self.attrs[\"points\"]=\" \".join([str(point[0])+\",\"+str(point[1])for point in pointlist])\n  if objid:self.id=objid\n  \n def _update(self):\n  self.attrs[\"points\"]=\" \".join([str(point[0])+\",\"+str(point[1])for point in self._pointList])\n  \n def __repr__(self):\n  return f\"polygon {self.id}\"if self.id else f\"polygon {id(self)}\"\n  \n def __str__(self):\n  return self.__repr__()\n  \n @property\n def pointList(self):\n  if getattr(self,\"_pointList\",None )is None :\n  \n   P=self.points\n   L=P.numberOfItems\n   self._pointList=[Point([P.getItem(i).x,P.getItem(i).y])for i in range(L)]\n  return self._pointList\n  \n @pointList.setter\n def pointList(self,pointlist):\n  self._pointList=[Point(coords)for coords in pointlist]\n  self._update()\n  \n def setPointList(self,pointlist):\n  self._pointList=[Point(coords)for coords in pointlist]\n  self._update()\n  \n def cloneObject(self):\n  newobject=self.__class__()\n  for key in self.attrs:\n   value=self.attrs[key]\n   newobject.attrs[key]=value\n  newobject.id=\"\"\n  \n  P=self.points\n  P2=newobject.points\n  L=P.numberOfItems\n  P2.clear()\n  for i in range(L):\n   pt=P.getItem(i)\n   P2.appendItem(pt)\n   \n  return newobject\n  \n def _transformpoints(self,points,matrix):\n  L=points.numberOfItems\n  for i in range(L):\n   pt=points.getItem(i)\n   newpt=pt.matrixTransform(matrix)\n   points.replaceItem(newpt,i)\n   \nclass RectangleObject(svg.rect,ObjectMixin):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,pointlist=None ,centre=(0,0),width=0,height=None ,angle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  svg.rect.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self.angle=angle\n  if pointlist:\n   self.setPointList(pointlist)\n  else :\n   self.centre=Point(centre)\n   if not height:height=width\n   if height and not width:width=height\n   self._width=width\n   self._height=height\n   self.setPosition()\n  if objid:self.id=objid\n  \n def setPosition(self,centre=None ,width=None ,height=None ,angle=None ,preserveaspectratio=False ):\n  ''\n\n  \n  if centre:self.centre=Point(centre)\n  if width:\n   self._width=width\n   if preserveaspectratio and not height:self._height=width *self.currentAspectRatio\n  if height:\n   self._height=height\n   if preserveaspectratio and not width:self._width=height /self.currentAspectRatio\n  if angle is not None :self.angle=angle\n  \n  (cx,cy)=self.centre\n  self.pointList=[(cx -self._width /2,cy -self._height /2),(cx+self._width /2,cy+self._height /2)]\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.pointList=self._transformedpointlist(t.matrix)\n  self._update()\n  self._updatehittarget()\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  self.centre=Point((cx,cy))\n  self.rotatestring=self.style.transform=f\"translate({cx}px,{cy}px) rotate({self.angle}deg) translate({-cx}px,{-cy}px)\"\n  \n  t=svgbase.createSVGTransform()\n  t.setRotate(-self.angle,cx,cy)\n  basepointlist=self._transformedpointlist(t.matrix)\n  [(x1,y1),(x2,y2)]=basepointlist\n  self._width=abs(x2 -x1)\n  self._height=abs(y2 -y1)\n  if self._width !=0:self.currentAspectRatio=self._height /self._width\n  self.attrs[\"x\"]=x2 if x2 <x1 else x1\n  self.attrs[\"y\"]=y2 if y2 <y1 else y1\n  self.attrs[\"width\"]=self._width\n  self.attrs[\"height\"]=self._height\n  \nclass EllipseObject(svg.ellipse,ObjectMixin):\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,pointlist=None ,centre=(0,0),width=0,height=None ,angle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  svg.ellipse.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self.angle=angle\n  if pointlist:\n   self.setPointList(pointlist)\n  else :\n   self.centre=Point(centre)\n   if not height:height=width\n   if height and not width:width=height\n   self._width=width\n   self._height=height\n   self.setPosition()\n  if objid:self.id=objid\n  \n def setPosition(self,centre=None ,width=None ,height=None ,angle=None ,preserveaspectratio=False ):\n  ''\n\n  \n  if centre:self.centre=Point(centre)\n  if width:\n   self._width=width\n   if preserveaspectratio and not height:self._height=width *self.currentAspectRatio\n  if height:\n   self._height=height\n   if preserveaspectratio and not width:self._width=height /self.currentAspectRatio\n  if angle is not None :self.angle=angle\n  \n  (cx,cy)=self.centre\n  self.pointList=[(cx -self._width /2,cy -self._height /2),(cx+self._width /2,cy+self._height /2)]\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.pointList=self._transformedpointlist(t.matrix)\n  self._update()\n  self._updatehittarget()\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  self.centre=Point((cx,cy))\n  self.rotatestring=self.style.transform=f\"translate({cx}px,{cy}px) rotate({self.angle}deg) translate({-cx}px,{-cy}px)\"\n  \n  t=svgbase.createSVGTransform()\n  t.setRotate(-self.angle,cx,cy)\n  basepointlist=self._transformedpointlist(t.matrix)\n  [(x1,y1),(x2,y2)]=basepointlist\n  self._width=abs(x2 -x1)\n  self._height=abs(y2 -y1)\n  if self._width !=0:self.currentAspectRatio=self._height /self._width\n  self.attrs[\"cx\"]=(x1+x2)/2\n  self.attrs[\"cy\"]=(y1+y2)/2\n  self.attrs[\"rx\"]=self._width /2\n  self.attrs[\"ry\"]=self._height /2\n  \nclass CircleObject(svg.circle,ObjectMixin):\n ''\n\n \n def __init__(self,centre=(0,0),radius=0,pointlist=None ,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  if pointlist:\n   self.pointList=[Point(coords)for coords in pointlist]\n  else :\n   (x,y)=centre\n   self.pointList=[Point((x,y)),Point((x+radius,y))]\n  svg.circle.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self._update()\n  if objid:self.id=objid\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  self.attrs[\"cx\"]=x1\n  self.attrs[\"cy\"]=y1\n  self.attrs[\"r\"]=hypot(x2 -x1,y2 -y1)\n  \nclass SectorObject(svg.path,ObjectMixin):\n ''\n\n\n\n \n def __init__(self,centre=(0,0),radius=0,startangle=0,endangle=0,pointlist=None ,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  self.centre=Point(centre)\n  self.radius=radius\n  self.startangle=startangle\n  self.endangle=endangle\n  if pointlist:\n   self.pointList=pointlist\n  else :\n   (cx,cy)=centre\n   point1=Point((cx+radius *sin(startangle *pi /180),cy -radius *cos(startangle *pi /180)))\n   point2=Point((cx+radius *sin(endangle *pi /180),cy -radius *cos(endangle *pi /180)))\n   self.pointList=[self.centre,point1,point2]\n  svg.path.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  self._update()\n  if objid:self.id=objid\n  \n def _update(self):\n  [(x0,y0),(x1,y1)]=self.pointList[:2]\n  (x2,y2)=self.pointList[-1]\n  r=hypot(x1 -x0,y1 -y0)\n  largeArcFlag=1 if (self.endangle -self.startangle)%360 >180 else 0\n  self.attrs[\"d\"]=f\"M {x0} {y0} L {x1} {y1} A {r} {r} 0 {largeArcFlag} 1 {x2} {y2} Z\"\n  \nclass UseObject(svg.use,ObjectMixin):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,href=None ,origin=None ,centre=(0,0),width=None ,height=None ,angle=0,scale=None ,objid=None ):\n  svg.use.__init__(self,href=href)\n  document <=svgbase\n  tempgroup=svg.g()\n  tempgroup <=self\n  svgbase <=tempgroup\n  bbox=tempgroup.getBBox()\n  svgbase.removeChild(tempgroup)\n  document.body.removeChild(svgbase)\n  self._origwidth=bbox.width\n  self._origheight=bbox.height\n  self._origaspectratio=self._origheight /self._origwidth\n  (cx,cy)=(bbox.x+bbox.width /2,bbox.y+bbox.height /2)\n  self.originoffset=Point((-cx,-cy))\n  \n  if width and height:\n   (self._width,self._height)=(width,height)\n  elif width:\n   (self._width,self._height)=(width,width *self._origaspectratio)\n  elif height:\n   (self._width,self._height)=(height /self._origaspectratio,height)\n  else :\n   (self._width,self._height)=(self._origwidth,self._origheight)\n   \n   \n  if origin:\n   scalefactors=(self._width /self._origwidth,self._height /self._origheight)\n   self.centre=Point(origin)-self.originoffset *scalefactors\n  else :\n   self.centre=Point(centre)\n  self.angle=angle\n  self.setPosition()\n  if objid:self.id=objid\n  \n def setPosition(self,origin=None ,centre=None ,width=None ,height=None ,angle=None ,preserveaspectratio=False ):\n  ''\n\n\n  \n  if width:\n   self._width=width\n   if preserveaspectratio and not height:self._height=width *self.currentAspectRatio\n  if height:\n   self._height=height\n   if preserveaspectratio and not width:self._width=height /self.currentAspectRatio\n  if self._width !=0:self.currentAspectRatio=self._height /self._width\n  \n  if origin:\n   scalefactors=(self._width /self._origwidth,self._height /self._origheight)\n   self.centre=Point(origin)-self.originoffset *scalefactors\n  elif centre:\n   self.centre=Point(centre)\n  if angle is not None :self.angle=angle\n  \n  (cx,cy)=self.centre\n  self.pointList=[(cx -self._width /2,cy -self._height /2),(cx+self._width /2,cy+self._height /2)]\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.pointList=self._transformedpointlist(t.matrix)\n  self._update()\n  self._updatehittarget()\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  self.centre=Point((cx,cy))\n  self.rotatestring=f\"translate({cx}px,{cy}px) rotate({self.angle}deg) translate({-cx}px,{-cy}px)\"\n  (xscale,yscale)=(self._width /self._origwidth,self._height /self._origheight)\n  self.scalestring=f\"translate({cx}px,{cy}px) scale({xscale},{yscale}) translate({-cx}px,{-cy}px)\"\n  self.style.transform=self.rotatestring+self.scalestring\n  self.origin=self.centre+self.originoffset\n  (self.attrs[\"x\"],self.attrs[\"y\"])=self.origin\n  \nclass ImageObject(svg.image,ObjectMixin):\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,href=None ,pointlist=None ,centre=(0,0),width=0,height=None ,angle=0,objid=None ):\n  def initialise(event):\n   nonlocal width,height\n   self.imageWidth=img.naturalWidth\n   self.imageHeight=img.naturalHeight\n   \n   self.imageAspectRatio=self.imageHeight /self.imageWidth\n   \n   self.attrs[\"preserveAspectRatio\"]=\"none\"\n   self.angle=angle\n   if pointlist:\n    self.setPointList(pointlist)\n   else :\n    self.centre=Point(centre)\n    if not width and not height:\n     width=self.imageWidth\n     height=self.imageHeight\n    elif not height:\n     height=width *self.imageAspectRatio\n    elif not width:\n     width=height /self.imageAspectRatio\n    self._width=width\n    self._height=height\n    self._setuppointlist()\n   self.style.visibility=\"visible\"\n   self.imageloaded=True\n   loadcomplete=window.Event.new(\"loadcomplete\")\n   self.dispatchEvent(loadcomplete)\n   \n  super().__init__()\n  if objid:self.id=objid\n  self.imageloaded=False\n  self.style.visibility=\"hidden\"\n  if not href:return\n  self.attrs[\"href\"]=href\n  img=html.IMG()\n  img.bind(\"load\",initialise)\n  img.attrs[\"src\"]=href\n  \n def setPosition(self,centre=None ,width=None ,height=None ,angle=None ,preserveaspectratio=False ):\n  ''\n\n  \n  def set_position(event=None ):\n  \n   if centre:self.centre=Point(centre)\n   if width:\n    self._width=width\n    if preserveaspectratio and not height:self._height=width *self.currentAspectRatio\n   if height:\n    self._height=height\n    if preserveaspectratio and not width:self._width=height /self.currentAspectRatio\n   if angle is not None :self.angle=angle\n   self._setuppointlist()\n   \n  if self.imageloaded:\n   set_position()\n  else :\n   self.bind(\"loadcomplete\",set_position)\n   \n def _setuppointlist(self):\n  (cx,cy)=self.centre\n  self.pointList=[(cx -self._width /2,cy -self._height /2),(cx+self._width /2,cy+self._height /2)]\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.pointList=self._transformedpointlist(t.matrix)\n  self._update()\n  self._updatehittarget()\n  \n def _update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  self.centre=Point((cx,cy))\n  self.rotatestring=self.style.transform=f\"translate({cx}px,{cy}px) rotate({self.angle}deg) translate({-cx}px,{-cy}px)\"\n  \n  t=svgbase.createSVGTransform()\n  t.setRotate(-self.angle,cx,cy)\n  basepointlist=self._transformedpointlist(t.matrix)\n  [(x1,y1),(x2,y2)]=basepointlist\n  self._width=abs(x2 -x1)\n  self._height=abs(y2 -y1)\n  if self._width !=0:self.currentAspectRatio=self._height /self._width\n  self.attrs[\"x\"]=x2 if x2 <x1 else x1\n  self.attrs[\"y\"]=y2 if y2 <y1 else y1\n  self.attrs[\"width\"]=self._width\n  self.attrs[\"height\"]=self._height\n  \nclass BezierObject(svg.path,ObjectMixin):\n ''\n\n\n\n\n \n def __init__(self,pointsetlist=None ,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\",objid=None ):\n  def toPoint(coords):\n   return None if coords is None else Point(coords)\n  svg.path.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  if pointsetlist:\n   self.pointList=[Point(pointset[1])for pointset in pointsetlist]\n  else :\n   self.pointList=[Point(coords)for coords in pointlist]\n   pointsetlist=self._getpointsetlist(self.pointList)\n  self.pointsetList=[[toPoint(coords)for coords in pointset]for pointset in pointsetlist]\n  self._update()\n  if objid:self.id=objid\n  \n def _getpointsetlist(self,pointlist):\n  pointsetlist=[[None ,pointlist[0],(pointlist[0]+pointlist[1])/2]]\n  for i in range(1,len(pointlist)-1):\n   pointsetlist.append([(pointlist[i -1]+pointlist[i])/2,pointlist[i],(pointlist[i]+pointlist[i+1])/2])\n  pointsetlist.append([(pointlist[-2]+pointlist[-1])/2,pointlist[-1],None ])\n  return pointsetlist\n  \n def _updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=[[None ]+self.pointList,self.pointList+[None ]]\n  else :\n   cpoint=(self.pointList[-1]+self.pointList[-2])/2\n   self.pointsetList[-1]=[cpoint,self.pointList[-1],None ]\n   self.pointsetList[-2][2]=cpoint\n   \n def _update(self):\n  (dummy,(x1,y1),(c1x,c1y))=self.pointsetList[0]\n  ((c2x,c2y),(x2,y2),dummy)=self.pointsetList[-1]\n  self.plist=[\"M\",x1,y1,\"C\",c1x,c1y]+[x for p in self.pointsetList[1:-1]for c in p for x in c]+[c2x,c2y,x2,y2]\n  self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  \nclass ClosedBezierObject(BezierObject):\n ''\n\n\n\n \n def __init__(self,pointsetlist=None ,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  svg.path.__init__(self,style={\"stroke\":linecolour,\"stroke-width\":linewidth,\"fill\":fillcolour})\n  if pointsetlist:\n   self.pointList=[Point(pointset[1])for pointset in pointsetlist]\n  else :\n   self.pointList=[Point(coords)for coords in pointlist]\n   pointsetlist=self._getpointsetlist(self.pointList)\n  self.pointsetList=[[Point(coords)for coords in pointset]for pointset in pointsetlist]\n  self._update()\n  if objid:self.id=objid\n  \n def _getpointsetlist(self,pointlist):\n  pointsetlist=[[(pointlist[0]+pointlist[-1])/2,pointlist[0],(pointlist[0]+pointlist[1])/2]]\n  for i in range(1,len(pointlist)-1):\n   pointsetlist.append([(pointlist[i -1]+pointlist[i])/2,pointlist[i],(pointlist[i]+pointlist[i+1])/2])\n  pointsetlist.append([(pointlist[-2]+pointlist[-1])/2,pointlist[-1],(pointlist[0]+pointlist[-1])/2])\n  return pointsetlist\n  \n def _updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=self._getpointsetlist(self.pointList)\n  else :\n   cpoint1,cpoint2=(self.pointList[-1]+self.pointList[-2])/2,(self.pointList[-1]+self.pointList[0])/2\n   self.pointsetList[-1]=(cpoint1,self.pointList[-1],cpoint2)\n   self.pointsetList[-2][2]=cpoint1\n   self.pointsetList[0][0]=cpoint2\n   \n def _update(self):\n  ((c1x,c1y),(x,y),(c2x,c2y))=self.pointsetList[0]\n  self.plist=[\"M\",x,y,\"C\",c2x,c2y]+[x for p in self.pointsetList[1:]for c in p for x in c]+[c1x,c1y,x,y]\n  self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  \nclass SmoothBezierObject(SmoothBezierMixin,BezierObject):\n ''\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\",objid=None ):\n  self.pointList=[Point(coords)for coords in pointlist]\n  pointsetlist=self._getpointsetlist(self.pointList)\n  BezierObject.__init__(self,pointsetlist,linecolour=linecolour,linewidth=linewidth,fillcolour=fillcolour,objid=objid)\n  \n def _getpointsetlist(self,pointlist):\n  if len(pointlist)==2:return [[None ]+pointlist,pointlist+[None ]]\n  for i in range(1,len(pointlist)-1):\n   (c1,c2)=self._calculatecontrolpoints(pointlist[i -1:i+2])\n   if i ==1:\n    pointsetlist=[[None ,pointlist[0],(pointlist[0]+c1)/2]]\n   pointsetlist.append([c1,pointlist[i],c2])\n  pointsetlist.append([(pointlist[-1]+c2)/2,pointlist[-1],None ])\n  return pointsetlist\n  \n def _updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=[[None ]+self.pointList,self.pointList+[None ]]\n  else :\n   (c1,c2)=self._calculatecontrolpoints(self.pointList[-3:])\n   self.pointsetList[-1]=[(self.pointList[-1]+c2)/2,self.pointList[-1],None ]\n   self.pointsetList[-2]=[c1,self.pointList[-2],c2]\n   \nclass SmoothClosedBezierObject(SmoothBezierMixin,ClosedBezierObject):\n ''\n\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  self.pointList=[Point(coords)for coords in pointlist]\n  pointsetlist=self._getpointsetlist(self.pointList)\n  ClosedBezierObject.__init__(self,pointsetlist,linecolour=linecolour,linewidth=linewidth,fillcolour=fillcolour,objid=objid)\n  \n def _getpointsetlist(self,pointlist):\n  pointlist=[pointlist[-1]]+pointlist[:]+[pointlist[0]]\n  pointsetlist=[]\n  for i in range(1,len(pointlist)-1):\n   (c1,c2)=self._calculatecontrolpoints(pointlist[i -1:i+2])\n   pointsetlist.append([c1,pointlist[i],c2])\n  return pointsetlist\n  \n def _updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=self._getpointsetlist(self.pointList)\n  else :\n   L=len(self.pointList)\n   pointlist=self.pointList[:]+self.pointList[:2]\n   for j in range(L -2,L+1):\n    (c1,c2)=self._calculatecontrolpoints(pointlist[j -1:j+2])\n    self.pointsetList[j %L]=[c1,pointlist[j],c2]\n    \nclass PointObject(svg.circle,ObjectMixin):\n ''\n\n \n def __init__(self,XY=(0,0),colour=\"black\",pointsize=2,canvas=None ,objid=None ):\n  (x,y)=XY\n  sf=canvas.scaleFactor if canvas else 1\n  svg.circle.__init__(self,cx=x,cy=y,r=pointsize *sf,style={\"stroke\":colour,\"stroke-width\":1,\"fill\":colour,\"vector-effect\":\"non-scaling-stroke\"})\n  self._XY=None\n  self.XY=Point(XY)\n  if objid:self.id=objid\n  \n def _update(self):\n  pass\n  \n @property\n def XY(self):\n  return self._XY\n  \n @XY.setter\n def XY(self,XY):\n  self._XY=Point(XY)\n  self.attrs[\"cx\"]=self._XY[0]\n  self.attrs[\"cy\"]=self._XY[1]\n  \nclass RegularPolygon(PolygonObject):\n ''\n\n\n\n \n def __init__(self,sidecount=0,centre=None ,radius=None ,startpoint=None ,sidelength=None ,offsetangle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\",objid=None ):\n  pointlist=[]\n  if sidecount >0:\n   angle=2 *pi /sidecount\n   radoffset=offsetangle *pi /180\n   if not radius:radius=sidelength /(2 *sin(pi /sidecount))\n   if not centre:\n    (x,y)=startpoint\n    centre=(x -radius *sin(radoffset),y+radius *cos(radoffset))\n   (cx,cy)=centre\n   for i in range(sidecount):\n    t=radoffset+i *angle\n    pointlist.append(Point((cx+radius *sin(t),cy -radius *cos(t))))\n  PolygonObject.__init__(self,pointlist,linecolour,linewidth,fillcolour,objid)\n  if objid:self.id=objid\n  \nclass GroupObject(svg.g,ObjectMixin):\n ''\n\n\n\n\n\n\n\n \n def __init__(self,objlist=[],objid=None ):\n  svg.g.__init__(self)\n  if not isinstance(objlist,list):objlist=[objlist]\n  self.objectList=[]\n  self._canvas=None\n  for obj in objlist:\n   self.addObject(obj)\n  if objid:self.id=objid\n  \n def addObject(self,svgobject):\n  canvas=self.canvas\n  if canvas is not None :canvas.addObject(svgobject)\n  self <=svgobject\n  svgobject.group=self\n  self.objectList.append(svgobject)\n  \n def addObjects(self,objectlist):\n  canvas=self.canvas\n  for obj in objectlist:\n   if canvas is not None :canvas.addObject(obj)\n   self <=obj\n   obj.group=self\n   self.objectList.append(obj)\n   \n def _update(self):\n  pass\n  \n def removeObject(self,svgobject):\n  if not self.contains(svgobject):return\n  self.removeChild(svgobject)\n  self.objectList.remove(svgobject)\n  svgobject.group=None\n  try :\n   del self.canvas.objectDict[svgobject.id]\n  except (AttributeError,KeyError):\n   pass\n   \n def deleteAll(self):\n  if self.canvas:\n   for obj in self.objectList:del self.canvas.objectDict[obj.id]\n  while self.firstChild:self.removeChild(self.firstChild)\n  self.objectList=[]\n  \n def setStyle(self,attribute,value):\n  for obj in self.objectList:\n   obj.setStyle(attribute,value)\n   \n @property\n def canvas(self):\n  return self._canvas\n  \n @canvas.setter\n def canvas(self,canvas):\n  self._canvas=canvas\n  for obj in self.objectList:obj.canvas=canvas\n  \n @property\n def fixed(self):\n  return self._fixed\n  \n @fixed.setter\n def fixed(self,fixedvalue):\n  self._fixed=fixedvalue\n  for obj in self.objectList:obj.fixed=fixedvalue\n  \nclass Button(GroupObject):\n ''\n\n\n\n\n\n\n\n \n def __init__(self,position,size,text,onclick,fontsize=None ,fillcolour=\"lightgrey\",canvas=None ,objid=None ):\n  GroupObject.__init__(self)\n  if objid:self.id=objid\n  (x,y),(width,height)=position,size\n  self.button=RectangleObject([(x,y),(x+width,y+height)],fillcolour=fillcolour)\n  self.button.attrs[\"rx\"]=height /3\n  rowcount=text.count(\"\\n\")+1\n  if not fontsize:fontsize=height *0.75 /rowcount\n  self.label=TextObject(text,(x+width /2,y+height /2 -fontsize /8),anchorposition=5,fontsize=fontsize)\n  self.addObjects([self.button,self.label])\n  self.fixed=True\n  self.bind(\"mousedown\",self._onMouseDown)\n  self.bind(\"mouseup\",self._onMouseUp)\n  self.bind(\"click\",onclick)\n  self.bind(\"touchstart\",onclick)\n  self.attrs[\"cursor\"]=\"pointer\"\n  \n def _onMouseDown(self,event):\n  event.stopPropagation()\n  \n def _onMouseUp(self,event):\n  event.stopPropagation()\n  \n def setFillColour(self,colour):\n  self.button.style.fill=colour\n  \nclass ImageButton(GroupObject):\n ''\n\n\n \n def __init__(self,position,size,image,onclick,fontsize=None ,fillcolour=\"lightgrey\",canvas=None ,objid=None ):\n  GroupObject.__init__(self)\n  if objid:self.id=objid\n  (x,y),(width,height)=position,size\n  self.button=RectangleObject([(x,y),(x+width,y+height)],fillcolour=fillcolour)\n  self.button.attrs[\"rx\"]=height /3\n  image.style.transform=f\"translate({x+width/2}px,{y+height/2}px)\"\n  if canvas:\n   canvas <=image\n   bbox=image.getBBox()\n   canvas.removeChild(image)\n   scalefactor=min(width /bbox.width,height /bbox.height)*0.7\n   image.style.transform +=f\" scale({scalefactor})\"\n  self.addObjects([self.button,image])\n  self.fixed=True\n  self.bind(\"mousedown\",self._onMouseDown)\n  self.bind(\"mouseup\",self._onMouseUp)\n  self.bind(\"click\",onclick)\n  self.bind(\"touchstart\",onclick)\n  self.attrs[\"cursor\"]=\"pointer\"\n  \n def _onMouseDown(self,event):\n  event.stopPropagation()\n  \n def _onMouseUp(self,event):\n  event.stopPropagation()\n  \n def setFillColour(self,colour):\n  self.button.style.fill=colour\n  \nclass Definitions(svg.defs):\n ''\n\n \n def __init__(self,objlist=[],filename=None ):\n  svg.defs.__init__(self)\n  if filename:\n   self.innerHTML=open(filename).read()\n  for obj in objlist:self <=obj\n  \nclass CanvasObject(svg.svg):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,width=None ,height=None ,colour=\"white\",objid=None ):\n  svg.svg.__init__(self,style={\"backgroundColor\":colour})\n  if width:self.style.width=width\n  if height:self.style.height=height\n  self.id=objid if objid else f\"canvas{id(self)}\"\n  self.objectDict={}\n  \n  \n  self.mouseMode=MouseMode.NONE\n  self.vertexSnap=False\n  self.snapDistance=10\n  self.lineWidthScaling=True\n  \n  self.edgeSnap=False\n  self.snapAngle=10\n  self.transformTypes=TransformType\n  self.penColour=\"black\"\n  self.fillColour=\"yellow\"\n  self.penWidth=3\n  \n  \n  self.scaleFactor=1\n  self.mouseDetected=False\n  self.mouseOwner=None\n  self.selectedObject=None\n  self.dragStartCoords=None\n  self.viewWindow=None\n  self.tool=\"select\"\n  \n  \n  self.panning=False\n  self.centre=None\n  self.nextid=0\n  self.objectDict={}\n  self.hittargets=[]\n  self.handles=None\n  self.controlhandles=None\n  self.transformHandles=[]\n  self.selectedhandle=None\n  self.transformorigin=None\n  self.transformBBox=RectangleObject(linecolour=\"blue\",fillcolour=\"none\")\n  self.transformBBox.style.vectorEffect=\"non-scaling-stroke\"\n  self.rotateLine=LineObject(linecolour=\"blue\")\n  self.rotateLine.style.vectorEffect=\"non-scaling-stroke\"\n  self.attrs[\"preserveAspectRatio\"]=\"xMidYMid meet\"\n  \n  self.bind(\"mousedown\",self._onMouseDown)\n  self.bind(\"mousemove\",self._onMouseMove)\n  self.bind(\"mouseup\",self._onLeftUp)\n  self.bind(\"touchstart\",self._onTouchStart)\n  self.bind(\"touchmove\",self._onMouseMove)\n  self.bind(\"touchend\",self._onLeftUp)\n  self.bind(\"dragstart\",self._onDragStart)\n  self.bind(\"dblclick\",self._onDoubleClick)\n  self.bind(\"contextmenu\",self._onRightClick)\n  self.bind(\"wheel\",self._onWheel)\n  document.bind(\"keydown\",self._onKeyDown)\n  \n  \n def setViewBox(self,pointlist):\n  ''\n\n\n  \n  ((x1,y1),(x2,y2))=pointlist\n  self.attrs[\"viewBox\"]=f\"{x1} {y1} {x2-x1} {y2-y1}\"\n  self.viewBoxRect=[Point((x1,y1)),Point((x2,y2))]\n  self.centre=Point(((x1+x2)/2,(y1+y2)/2))\n  self.xScaleFactor,self.yScaleFactor=self._getScaleFactors()\n  self.scaleFactor=max(self.xScaleFactor,self.yScaleFactor)\n  bcr=self.getBoundingClientRect()\n  pt=self.createSVGPoint()\n  (pt.x,pt.y)=(bcr.left,bcr.top)\n  SVGpt=pt.matrixTransform(self.getScreenCTM().inverse())\n  (x1,y1)=(SVGpt.x,SVGpt.y)\n  (pt.x,pt.y)=(bcr.left+bcr.width,bcr.top+bcr.height)\n  SVGpt=pt.matrixTransform(self.getScreenCTM().inverse())\n  (x2,y2)=(SVGpt.x,SVGpt.y)\n  self.viewWindow=[Point((x1,y1)),Point((x2,y2))]\n  return self.viewWindow\n  \n def _getDimensions(self):\n  ''\n\n  \n  bcr=self.getBoundingClientRect()\n  self.attrs[\"width\"]=bcr.width\n  self.attrs[\"height\"]=bcr.height\n  return bcr.width,bcr.height\n  \n def fitContents(self):\n  ''\n  \n  bbox=self.getBBox()\n  if bbox.width ==0 or bbox.height ==0:return\n  wmargin,hmargin=bbox.width /50,bbox.height /50\n  self.viewWindow=self.setViewBox(((bbox.x -wmargin,bbox.y -hmargin),(bbox.x+bbox.width+wmargin,bbox.y+bbox.height+hmargin)))\n  return self.viewWindow\n  \n def getSVGcoords(self,event):\n  ''\n  x=event.changedTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.changedTouches[0].clientY if \"touch\"in event.type else event.clientY\n  pt=self.createSVGPoint()\n  (pt.x,pt.y)=(x,y)\n  SVGpt=pt.matrixTransform(self.getScreenCTM().inverse())\n  return Point((SVGpt.x,SVGpt.y))\n  \n def addObject(self,svgobject,fixed=False ):\n  ''\n\n\n\n\n\n  \n  def AddToDict(svgobj):\n   if not svgobj.id:\n    svgobj.id=f\"{self.id}_id{self.nextid}\"\n    self.nextid +=1\n   self.objectDict[svgobj.id]=svgobj\n   if not getattr(svgobj.style,\"vectorEffect\",None ):\n    if self.lineWidthScaling is False :svgobj.style.vectorEffect=\"non-scaling-stroke\"\n   if isinstance(svgobj,GroupObject):\n    for obj in svgobj.objectList:\n     AddToDict(obj)\n  if not hasattr(svgobject,\"fixed\"):svgobject.fixed=fixed\n  self <=svgobject\n  AddToDict(svgobject)\n  svgobject.canvas=self\n  return svgobject\n  \n def addObjects(self,objectlist,fixed=False ):\n  ''\n  for obj in objectlist:\n   if isinstance(obj,(list,tuple)):\n    self.addObjects(obj,fixed=fixed)\n   else :\n    self.addObject(obj,fixed=fixed)\n    \n def deleteObject(self,svgobject):\n  ''\n  def deletefromdict(svgobj):\n   if isinstance(svgobj,GroupObject):\n    for obj in svgobj.objectList:\n     deletefromdict(obj)\n   hittarget=getattr(svgobj,\"hitTarget\",None )\n   if hittarget:self.deleteObject(hittarget)\n   if svgobj.id in self.objectDict:del self.objectDict[svgobj.id]\n   \n  if not self.contains(svgobject):return\n  self.removeChild(svgobject)\n  deletefromdict(svgobject)\n  \n def deleteAll(self,event=None ):\n  ''\n  while self.firstChild:\n   self.removeChild(self.firstChild)\n  self.objectDict={}\n  \n def deleteSelection(self):\n  ''\n  if self.selectedObject:\n   if self.handles:self.deleteObject(self.handles)\n   if self.controlhandles:self.deleteObject(self.controlhandles)\n   hittarget=getattr(self.selectedObject,\"hitTarget\",None )\n   if hittarget:self.deleteObject(hittarget)\n   self.deleteObject(self.selectedObject)\n   self.selectedObject=self.handles=self.controlhandles=None\n   \n def translateObject(self,svgobject,offset):\n  ''\n  \n  offset=Point(offset)\n  if isinstance(svgobject,GroupObject):\n   for obj in svgobject.objectList:\n    self.translateObject(obj,offset)\n   boundary=getattr(svgobject,\"boundary\",None )\n   if boundary:self.translateObject(boundary,offset)\n  elif isinstance(svgobject,PointObject):\n   svgobject.XY +=offset\n  else :\n   svgobject.pointList=[point+offset for point in svgobject.pointList]\n   if isinstance(svgobject,BezierObject):\n    svgobject.pointsetList=[(p1+offset,p2+offset,p3+offset)for (p1,p2,p3)in svgobject.pointsetList]\n   svgobject._update()\n   svgobject._updatehittarget()\n   if isinstance(svgobject,PolygonObject):svgobject._segments=None\n   \n   \n def rotateElement(self,element,angle,centre=None ):\n  ''\n  \n  if not centre:\n   bbox=element.getBBox()\n   centre=(bbox.x+bbox.width /2,bbox.y+bbox.height /2)\n  (cx,cy)=centre\n  transformstring=f\"translate({cx}px,{cy}px) rotate({angle}deg) translate({-cx}px,{-cy}px)\"\n  element.style.transform=transformstring+element.style.transform\n  t=svgbase.createSVGTransform()\n  t.setRotate(angle,*centre)\n  \n  return t.matrix\n  \n def scaleElement(self,element,xscale,yscale=None ):\n  ''\n  \n  if not yscale:yscale=xscale\n  transformstring=f\"scale({xscale},{yscale})\"\n  element.style.transform=transformstring+element.style.transform\n  t=svgbase.createSVGTransform()\n  t.setScale(xscale,yscale)\n  \n  return t.matrix\n  \n def translateElement(self,element,vector):\n  ''\n  (dx,dy)=vector\n  transformstring=f\"translate({dx}px,{dy}px)\"\n  element.style.transform=transformstring+element.style.transform\n  t=svgbase.createSVGTransform()\n  t.setTranslate(*vector)\n  \n  return t.matrix\n  \n  \n @property\n def mouseMode(self):\n  return self._mouseMode\n  \n @mouseMode.setter\n def mouseMode(self,mm):\n  if mm in [MouseMode.DRAG,MouseMode.EDIT,MouseMode.TRANSFORM]:\n   self.createHitTargets()\n  currentmm=getattr(self,\"_mouseMode\",None )\n  if currentmm ==mm:return\n  if currentmm ==MouseMode.TRANSFORM:self.hideTransformHandles()\n  elif currentmm ==MouseMode.EDIT:self.deselectObject()\n  self._mouseMode=mm\n  if mm in [MouseMode.DRAG,MouseMode.PAN,MouseMode.TRANSFORM]:\n   self.tool=\"select\"\n   \n @property\n def lineWidthScaling(self):\n  return self._lineWidthScaling\n  \n @lineWidthScaling.setter\n def lineWidthScaling(self,lws):\n  currentlws=getattr(self,\"_lineWidthScaling\",None )\n  if currentlws ==lws:return\n  self._lineWidthScaling=lws\n  for objid in self.objectDict:\n   self.objectDict[objid].style.vectorEffect=\"none\"if lws else \"non-scaling-stroke\"\n   \n def _getScaleFactors(self):\n  ''\n  width,height=self._getDimensions()\n  \n  vbleft,vbtop,vbwidth,vbheight=[float(x)for x in self.attrs[\"viewBox\"].split()]\n  xScaleFactor=vbwidth /width if width !=0 else 1\n  yScaleFactor=vbheight /height if height !=0 else 1\n  return xScaleFactor,yScaleFactor\n  \n def createHitTargets(self):\n  try :\n   self._createEditHitTargets()\n  except AttributeError:\n   self._createHitTargets()\n   \n def _createHitTargets(self):\n  objlist=list(self.objectDict.values())\n  for obj in objlist:\n   if isinstance(obj,GroupObject):continue\n   if hasattr(obj,\"hitTarget\"):continue\n   if hasattr(obj,\"reference\"):continue\n   if isinstance(obj,UseObject):\n    newobj=RectangleObject(pointlist=obj.pointList,angle=obj.angle)\n   elif obj.style.fill !=\"none\"or obj.fixed:\n    continue\n   else :\n    newobj=obj.cloneObject()\n    newobj.style.strokeWidth=10 *self.scaleFactor if self.mouseDetected else 25 *self.scaleFactor\n   newobj.style.opacity=0\n   for event in MOUSEEVENTS:newobj.bind(event,self._onHitTargetMouseEvent)\n   for event in TOUCHEVENTS:newobj.bind(event,self._onHitTargetTouchEvent)\n   newobj.reference=obj\n   obj.hitTarget=newobj\n   self.hittargets.append(newobj)\n   self.addObject(newobj)\n   \n def _onWheel(self,event):\n  if self.mouseMode ==MouseMode.PAN:\n   event.preventDefault()\n   zoomfactor=0.9 if event.deltaY <0 else 1.1\n   newviewbox=[self.centre+zoomfactor *(point -self.centre)for point in self.viewBoxRect]\n   self.setViewBox(newviewbox)\n   \n def _onRightClick(self,event):\n \n  pass\n  \n def _onDragStart(self,event):\n  event.preventDefault()\n  \n def _onTouchStart(self,event):\n  event.preventDefault()\n  global lasttaptime\n  latesttaptime=time.time()\n  if event.touches.length ==1 and latesttaptime -lasttaptime <0.3:\n   for function in self.events(\"dblclick\"):\n    function(event)\n  else :\n   self._onLeftDown(event)\n  lasttaptime=latesttaptime\n  \n def _onMouseDown(self,event):\n  event.preventDefault()\n  if not self.mouseDetected:\n   self.mouseDetected=True\n   for obj in self.objectDict.values():\n    if hasattr(obj,\"reference\"):\n     if isinstance(obj.reference,UseObject):continue\n     obj.style.strokeWidth=10 *self.scaleFactor\n  if event.button >0:return\n  self._onLeftDown(event)\n  \n def _onLeftDown(self,event):\n  if self.mouseMode ==MouseMode.DRAG:\n   self._prepareDrag(event)\n  elif self.mouseMode ==MouseMode.TRANSFORM:\n   self._prepareTransform(event)\n  elif self.mouseMode ==MouseMode.DRAW:\n   self._drawPoint(event)\n  elif self.mouseMode ==MouseMode.EDIT:\n   self._prepareEdit(event)\n  elif self.mouseMode ==MouseMode.PAN:\n   self._preparePan(event)\n   \n def _onMouseMove(self,event):\n  event.preventDefault()\n  if self.mouseMode ==MouseMode.PAN:\n   if self.panning:self._doPan(event)\n   return\n  if not self.mouseOwner:return\n  if self.mouseMode ==MouseMode.DRAG:\n   self._doDrag(event)\n  else :\n   self._movePoint(event)\n   \n def _onLeftUp(self,event):\n  if event.type ==\"mouseup\"and event.button >0:return\n  if self.mouseMode ==MouseMode.PAN:\n   self._endPan(event)\n   return\n  if not self.mouseOwner:return\n  if self.mouseMode ==MouseMode.DRAG:\n   self._endDrag(event)\n  elif self.mouseMode ==MouseMode.TRANSFORM:\n   self._endTransform(event)\n   self.mouseOwner=None\n  elif self.mouseMode ==MouseMode.EDIT:\n   self._endEdit(event)\n   \n def _onHitTargetMouseEvent(self,event):\n  eventdict={attr:getattr(event,attr)for attr in dir(event)}\n  eventdict[\"bubbles\"]=False\n  newevent=window.MouseEvent.new(event.type,eventdict)\n  obj=self.objectDict[event.target.id]\n  obj.reference.dispatchEvent(newevent)\n  \n def _onHitTargetTouchEvent(self,event):\n  eventdict={attr:getattr(event,attr)for attr in dir(event)}\n  eventdict[\"bubbles\"]=False\n  newevent=window.TouchEvent.new(event.type,eventdict)\n  obj=self.objectDict[event.target.id]\n  obj.reference.dispatchEvent(newevent)\n  latesttime=time.time()\n  if event.type ==\"touchend\"and latesttime -lasttaptime <0.6:\n   eventdict[\"clientX\"]=event.changedTouches[0].clientX\n   eventdict[\"clientY\"]=event.changedTouches[0].clientY\n   newevent=window.MouseEvent.new(\"click\",eventdict)\n   obj.reference.dispatchEvent(newevent)\n   \n def _onDoubleClick(self,event):\n  if self.mouseMode ==MouseMode.DRAW:\n   self.setTool(\"select\")\n  elif self.mouseMode ==MouseMode.PAN:\n   self.fitContents()\n   \n def _onKeyDown(self,event):\n  if event.keyCode ==46:self.deleteSelection()\n  \n def _prepareDrag(self,event):\n  self.dragStartCoords=self.getSVGcoords(event)\n  self.selectedObject=self.getSelectedObject(event.target.id)\n  if self.selectedObject and not self.selectedObject.fixed:\n   self.mouseOwner=self.selectedObject\n   self <=self.mouseOwner\n   if (hittarget :=getattr(self.mouseOwner,\"hitTarget\",None )):self <=hittarget\n   self.startx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n   self.starty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n   \n def _doDrag(self,event):\n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  dx,dy=(x -self.startx)*self.scaleFactor,(y -self.starty)*self.scaleFactor\n  self.mouseOwner.style.transform=f\"translate({dx}px,{dy}px)\"\n  if isinstance(self.mouseOwner,[EllipseObject,RectangleObject,UseObject,ImageObject]):\n   self.mouseOwner.style.transform +=self.mouseOwner.rotatestring\n   if isinstance(self.mouseOwner,UseObject):self.mouseOwner.style.transform +=self.mouseOwner.scalestring\n   \n def _endDrag(self,event):\n  self.mouseOwner.style.transform=\"translate(0px,0px)\"\n  currentcoords=self.getSVGcoords(event)\n  offset=currentcoords -self.dragStartCoords\n  self.translateObject(self.mouseOwner,offset)\n  if self.edgeSnap:self._doEdgeSnap(self.mouseOwner)\n  elif self.vertexSnap:self._doVertexSnap(self.mouseOwner)\n  self.mouseOwner=None\n  \n def _preparePan(self,event):\n  if not self.centre:\n   (width,height)=self._getDimensions()\n   self.setViewBox([(0,0),(width,height)])\n  if \"touch\"in event.type and event.touches.length ==2:\n   point0=Point((event.touches[0].clientX,event.touches[0].clientY))\n   point1=Point((event.touches[1].clientX,event.touches[1].clientY))\n   self.startZoomLength=(point1 -point0).length()\n   \n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.startPoint=Point((x,y))\n  self.startCentre=self.centre\n  self.panStart=self.viewBoxRect\n  self.panning=True\n  \n def _doPan(self,event):\n  if \"touch\"in event.type and event.touches.length ==2:\n   point0=Point((event.touches[0].clientX,event.touches[0].clientY))\n   point1=Point((event.touches[1].clientX,event.touches[1].clientY))\n   newzoomlength=(point1 -point0).length()\n   zoomfactor=self.startZoomLength /newzoomlength\n   \n   newviewbox=[self.centre+zoomfactor *(point -self.centre)for point in self.viewBoxRect]\n   self.setViewBox(newviewbox)\n   self.startZoomLength=newzoomlength\n  else :\n   x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n   y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n   sf=(self.xScaleFactor,self.yScaleFactor)if self.attrs[\"preserveAspectRatio\"]==\"none\"else self.scaleFactor\n   delta=(Point((x,y))-self.startPoint)*sf\n   \n   newviewbox=[point -delta for point in self.panStart]\n   self.setViewBox(newviewbox)\n   \n def _endPan(self,event):\n  self.panning=False\n  \n def getSelectedObject(self,objectid,getGroup=True ):\n  ''\n\n\n  \n  try :\n   svgobj=self.objectDict[objectid]\n  except KeyError:\n   return\n  try :\n   svgobj=svgobj.reference\n  except AttributeError:\n   pass\n  if getGroup:\n   while getattr(svgobj,\"group\",None ):\n    svgobj=svgobj.group\n  return svgobj\n  \n def _doVertexSnap(self,svgobject,checkpoints=None ):\n  if not hasattr(svgobject,\"pointList\"):return\n  snapd=self.snapDistance\n  bestdx=bestdy=bestd=None\n  bbox=svgobject.getBBox()\n  L,R,T,B=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n  \n  if checkpoints is None :\n   checkpoints=[]\n   for objid in self.objectDict:\n    if objid ==svgobject.id:continue\n    obj=self.objectDict[objid]\n    if not hasattr(obj,\"pointList\"):continue\n    if hasattr(obj,\"reference\"):continue\n    if obj.style.visibility ==\"hidden\":continue\n    if objgroup :=getattr(obj,\"group\",None )and hasattr(objgroup,\"pointList\"):continue\n    bbox=obj.getBBox()\n    L1,R1,T1,B1=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n    if L1 -R >snapd or R1 -L <-snapd or T1 -B >snapd or B1 -T <-snapd:continue\n    checkpoints.extend(obj.pointList)\n  if not checkpoints:return\n  checkpoints.sort(key=lambda p:p.coords)\n  objpoints=sorted(svgobject.pointList,key=lambda p:p.coords)\n  \n  checkstart=0\n  for i,point1 in enumerate(objpoints):\n   checkpoints=checkpoints[checkstart:]\n   if not checkpoints:break\n   try :\n    (tonextx,y)=objpoints[i+1]-point1\n   except IndexError:\n    tonextx=0\n   checkstart=0\n   for point2 in checkpoints:\n    (dx,dy)=point2 -point1\n    if abs(dx)<snapd and abs(dy)<snapd:\n     d=hypot(dx,dy)\n     if bestd is None or d <bestd:(bestd,bestdx,bestdy)=(d,dx,dy)\n    if tonextx -dx >snapd:checkstart +=1\n    if dx >snapd:break\n  if bestd:self.translateObject(svgobject,(bestdx,bestdy))\n  \nclass Point(object):\n ''\n def __init__(self,coords):\n  self.coords=list(coords.coords)if isinstance(coords,Point)else list(coords)\n  \n def __repr__(self):\n  return str(tuple(self.coords))\n  \n def __eq__(self,other):\n  if isinstance(other,Point):\n   return (self.coords ==other.coords)\n  elif isinstance(other,list):\n   return (self.coords ==other)\n  elif isinstance(other,tuple):\n   return (tuple(self.coords)==other)\n  else :\n   return False\n   \n def __lt__(self,other):\n  return self.coords <other.coords\n  \n def __add__(self,other):\n  if isinstance(other,Point):\n   return Point([xi+yi for (xi,yi)in zip(self.coords,other.coords)])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi+yi for (xi,yi)in zip(self.coords,other)])\n  elif other is None :\n   return None\n  else :\n   return NotImplemented\n   \n def __radd__(self,other):\n  return self+other\n  \n def __iadd__(self,other):\n  if isinstance(other,(list,tuple)):\n   for i in range(len(self.coords)):\n    self.coords[i]+=other[i]\n  else :\n   for i in range(len(self.coords)):\n    self.coords[i]+=other.coords[i]\n  return self\n  \n def __sub__(self,other):\n  return Point([xi -yi for (xi,yi)in zip(self.coords,other.coords)])\n  \n def __rsub__(self,other):\n  return Point([xi -yi for (xi,yi)in zip(other.coords,self.coords)])\n  \n def __neg__(self):\n  return Point([-xi for xi in self.coords])\n  \n def __mul__(self,other):\n  if isinstance(other,(int,float)):\n   return Point([other *xi for xi in self.coords])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi *yi for (xi,yi)in zip(self.coords,other)])\n  elif isinstance(other,Point):\n   return sum([xi *yi for (xi,yi)in zip(self.coords,other.coords)])\n  elif isinstance(other,Matrix):\n   return Point([self *col for col in other.cols])\n  else :\n   return NotImplemented\n   \n def __rmul__(self,other):\n  if isinstance(other,(int,float)):\n   return Point([other *xi for xi in self.coords])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi *yi for (xi,yi)in zip(self.coords,other)])\n  elif isinstance(other,Point):\n   return sum([xi *yi for (xi,yi)in zip(self.coords,other.coords)])\n  else :\n   return NotImplemented\n   \n def __truediv__(self,other):\n  return Point([xi /other for xi in self.coords])\n  \n def __getitem__(self,i):\n  return self.coords[i]\n  \n def __hash__(self):\n  return hash(tuple(self.coords))\n  \n def __round__(self,n):\n  (x,y)=self.coords\n  return Point((round(float(x),n),round(float(y),n)))\n  \n def __len__(self):\n  return len(self.coords)\n  \n def length(self):\n  (x,y)=self.coords\n  return hypot(x,y)\n  \n def angle(self):\n  return atan2(self.coords[1],self.coords[0])\n  \n def anglefrom(self,other):\n  dot=other *self\n  cross=other.cross(self)\n  if cross ==0:cross=-0.0\n  angle=atan2(cross,dot)\n  return angle\n  \n def cross(self,other):\n  x1,y1=self.coords\n  x2,y2=other.coords\n  return x1 *y2 -y1 *x2\n  \n def roundsf(self,sf):\n  x,y=self.coords\n  return Point((roundsf(x,sf),roundsf(y,sf)))\n  \nclass Matrix(object):\n def __init__(self,rows):\n  self.rows=rows\n  self.cols=[Point([self.rows[i][j]for i in range(len(self.rows))])for j in range(len(self.rows[0]))]\n  \n def __str__(self):\n  return str(\"\\n\".join(str(row)for row in self.rows))\n  \n def __rmul__(self,other):\n  if isinstance(other,(list,tuple)):\n   return [Point([p *col for col in self.cols])for p in other]\n  else :\n   return Point([other *col for col in self.cols])\n   \ndef roundsf(x,sf=3):\n if x ==0:return 0\n return round(x,sf -int(floor(log10(abs(x))))-1)\n \nshapetypes={\"line\":LineObject,\"polygon\":PolygonObject,\"polyline\":PolylineObject,\n\"rectangle\":RectangleObject,\"ellipse\":EllipseObject,\"circle\":CircleObject,\"sector\":SectorObject,\n\"bezier\":BezierObject,\"closedbezier\":ClosedBezierObject,\"smoothbezier\":SmoothBezierObject,\"smoothclosedbezier\":SmoothClosedBezierObject}\n", ["browser", "browser.html", "browser.svg", "math", "time"]], "brycharts.statfns": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nfrom math import ceil,sqrt\n\ndef mean(values):\n return sum(values)/len(values)\n \ndef sum2(values):\n return sum(x *x for x in values)\n \ndef variance(values):\n return (sum2(values)/len(values)-mean(values)**2)\n \ndef stdev(values):\n return variance(values)**0.5\n \ndef percentileindex(p,n):\n x=n *p /100\n return (int(x),True )if x ==int(x)else (int(x)+1,False )\n \ndef quartiles(values):\n values.sort()\n n=len(values)\n i,exact=percentileindex(25,n)\n Q1=(values[i]+values[i+1])/2 if exact else values[i]\n i,exact=percentileindex(50,n)\n Q2=(values[i]+values[i+1])/2 if exact else values[i]\n i,exact=percentileindex(75,n)\n Q3=(values[i]+values[i+1])/2 if exact else values[i]\n return (Q1,Q2,Q3)\n \ndef regressioninfo(points):\n n=len(points)\n xvalues=[x[0]for x in points]\n yvalues=[x[1]for x in points]\n sx=sum(xvalues)\n sx2=sum2(xvalues)\n Sxx=sx2 -sx *sx /n\n sy=sum(yvalues)\n sy2=sum2(yvalues)\n Syy=sy2 -sy *sy /n\n sxy=sum(x *y for (x,y)in points)\n Sxy=sxy -sx *sy /n\n pmcc=Sxy /(Sxx *Syy)**0.5\n gradient=Sxy /Sxx\n yintercept=(sy -gradient *sx)/n\n return pmcc,gradient,yintercept\n \ndef convertifnumber(string):\n try :\n  x=float(string)\n except ValueError:\n  return string\n else :\n  n=int(x)\n  return n if n ==x else x\n  \nif __name__ ==\"__main__\":\n points=[(164,6.5),(153,3),(163,4),(157,8),(161,5),(155,4),(168,4),(174,7),(167,6),(164,7),(159,3),(167,6)]\n pmcc,gradient,yintercept=regressioninfo(points)\n print(pmcc,gradient,yintercept)\n", ["math"]], "brycharts": [".py", "from .brycharts import *\n", ["brycharts.brycharts"], 1], "brycharts.brycharts": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nfrom collections import Counter\nfrom math import sin,cos,pi,log10,exp\n\nfrom . import dragcanvas as SVG\nfrom . import bryaxes\nfrom .roundfns import *\nfrom .statfns import *\n\nDEFAULT_COLOURS=[f\"hsl({a%360+22.5*(a//1080)},{(3-a//810)*100//3}%, 50%)\"for a in range(0,2160,135)]\n\n\n\nclass LabelledData(dict):\n def __init__(self,data,valueslabel):\n  super().__init__(data)\n  self.valuesLabel=valueslabel\n  self.labels=list(self.keys())\n  self.Values=list(self.values())\n  self.maxValue=max(self.Values)\n  self.total=sum(self.Values)\n  self.percentages=[100 *value /self.total for value in self.Values]\n  \nclass LabelledDataDict(dict):\n def __init__(self,datadict,valueslabel):\n  if not isinstance(next(iter(datadict.values())),LabelledData):\n   datadict={key:LabelledData(ld,valueslabel)for (key,ld)in datadict.items()}\n  super().__init__(datadict)\n  self.maxValue=max(ld.maxValue for ld in self.values())\n  self.valuesLabel=valueslabel\n  labels=set()\n  for ld in self.values():labels.update(ld.keys())\n  self.labels=list(labels)\n  self.Values={label:[]for label in self.labels}\n  self.sums={label:[0]for label in self.labels}\n  for label in self.labels:\n   for ld in self.values():\n    value=ld.get(label,0)\n    self.Values[label].append(value)\n    self.sums[label].append(self.sums[label][-1]+value)\n  self.maxSum=max(sums[-1]for sums in self.sums.values())\n  \nclass FrequencyData(LabelledData):\n def __init__(self,data=None ,rawdata=None ,valueslabel=\"Frequency\"):\n  if rawdata:\n   data=self.fromRawData(rawdata)\n  super().__init__(data,valueslabel)\n  \n def fromRawData(self,rawdata):\n  return sorted(Counter(rawdata).items())\n  \nclass FrequencyDataDict(LabelledDataDict):\n def __init__(self,datadict=None ,rawdatadict=None ,valueslabel=\"Frequency\"):\n  if rawdatadict:\n   fdd={key:FrequencyData(rawdata=rawdata,valueslabel=valueslabel)for (key,rawdata)in rawdatadict.items()}\n  else :\n   fdd={key:FrequencyData(data=data,valueslabel=valueslabel)for (key,data)in datadict.items()}\n  super().__init__(fdd,valueslabel)\n  \nclass PairedData(list):\n def __init__(self,xlabel,yLabel,data):\n  super().__init__(data)\n  self.xLabel=xlabel\n  self.yLabel=yLabel\n  self.xValues=[item[0]for item in data]\n  self.yValues=[item[1]for item in data]\n  self.xMin,self.xMax=min(self.xValues),max(self.xValues)\n  self.yMin,self.yMax=min(self.yValues),max(self.yValues)\n  \nclass PairedDataDict(dict):\n def __init__(self,xlabel,yLabel,datadict):\n  pdd={key:PairedData(xlabel,yLabel,pd)for (key,pd)in datadict.items()}\n  super().__init__(pdd)\n  self.xLabel=xlabel\n  self.yLabel=yLabel\n  self.xMin=min(pd.xMin for pd in pdd.values())\n  self.xMax=max(pd.xMax for pd in pdd.values())\n  self.yMin=min(pd.yMin for pd in pdd.values())\n  self.yMax=max(pd.yMax for pd in pdd.values())\n  \nclass LabelledPairedData(dict):\n def __init__(self,xlabel,yLabel,data):\n  super().__init__(data)\n  self.xLabel=xlabel\n  self.yLabel=yLabel\n  self.xValues=[item[0]for item in data.values()]\n  self.yValues=[item[1]for item in data.values()]\n  self.xMin,self.xMax=min(self.xValues),max(self.xValues)\n  self.yMin,self.yMax=min(self.yValues),max(self.yValues)\n  \nclass LabelledPairedDataDict(dict):\n def __init__(self,xlabel,yLabel,datadict):\n  lpdd={key:LabelledPairedData(xlabel,yLabel,lpd)for (key,lpd)in datadict.items()}\n  super().__init__(lpdd)\n  self.xLabel=xlabel\n  self.yLabel=yLabel\n  self.xMin=min(lpd.xMin for lpd in lpdd.values())\n  self.xMax=max(lpd.xMax for lpd in lpdd.values())\n  self.yMin=min(lpd.yMin for lpd in lpdd.values())\n  self.yMax=max(lpd.yMax for lpd in lpdd.values())\n  \nclass BoxPlotData(list):\n def __init__(self,valueslabel,boxplotdata=None ,rawdata=None ):\n  if rawdata:\n   Q1,Q2,Q3=quartiles(rawdata)\n   boxplotdata=[min(rawdata),Q1,Q2,Q3,max(rawdata)]\n  super().__init__(boxplotdata)\n  self.valuesLabel=valueslabel\n  self.xMin=self[0]\n  self.xMax=self[-1]\n  \nclass BoxPlotDataDict(dict):\n def __init__(self,valueslabel,boxplotdatadict=None ,rawdatadict=None ):\n  if rawdatadict:\n   boxplotdatadict={}\n   for key,rawdata in rawdatadict.items():\n    boxplotdatadict[key]=BoxPlotData(valueslabel,rawdata=rawdata)\n  else :\n   boxplotdatadict={key:BoxPlotData(valueslabel,boxplotdata)for key,boxplotdata in boxplotdatadict.items()}\n  super().__init__(boxplotdatadict)\n  self.xMin=min(bpd.xMin for bpd in self.values())\n  self.xMax=max(bpd.xMax for bpd in self.values())\n  self.valuesLabel=valueslabel\n  \nclass GroupedFrequencyData(list):\n def __init__(self,valueslabel,data=None ,rawdata=None ,boundaries=None ,classwidth=None ):\n  if data:\n   (b,f)=data[-1]\n   if f !=0:data.append((2 *b -data[-2][0],0))\n  else :\n   datamin,datamax=min(rawdata),max(rawdata)\n   datarange=datamax -datamin\n   if not boundaries:\n    if not classwidth:classwidth,_=roundscale(datarange,5)\n    minboundary=rounddown(datamin,classwidth)\n    maxboundary=roundup(datamax,classwidth)\n    boundaries=[minboundary]\n    while boundaries[-1]<maxboundary:boundaries.append(boundaries[-1]+classwidth)\n   else :\n    if datamin <boundaries[0]:\n     classwidth=boundaries[1]-boundaries[0]\n     boundaries.insert(0,rounddown(datamin,classwidth))\n    if datamax >boundaries[-1]:\n     classwidth=boundaries[-1]-boundaries[-2]\n     boundaries.append(roundup(datamax,classwidth))\n   data=self.fromRawData(rawdata,boundaries)\n  super().__init__(data)\n  self.boundaries=[item[0]for item in data]\n  self.frequencies=[item[1]for item in data]\n  self.xMin,self.xMax=self.boundaries[0],self.boundaries[-1]\n  self.maxFrequency=max(self.frequencies)\n  self.frequencyDensities=[]\n  for i in range(len(self.boundaries)-1):\n   self.frequencyDensities.append(self.frequencies[i]/(self.boundaries[i+1]-self.boundaries[i]))\n  self.maxFrequencyDensity=max(self.frequencyDensities)\n  self.valuesLabel=valueslabel\n  \n  \n  \n def fromRawData(self,rawdata,boundaries):\n  L=len(boundaries)\n  frequencies=[0]*L\n  for value in rawdata:\n   for i in range(L):\n    if value <boundaries[i+1]:\n     frequencies[i]+=1\n     break\n  return list(zip(boundaries,frequencies))\n  \n def mean(self):\n  self.midpoints=[(self[i][0]+self[i+1][0])/2 for i in range(len(self)-1)]\n  sumfx=sum(x *f for (x,f)in zip(self.midpoints,self.frequencies[:-1]))\n  sumf=sum(self.frequencies)\n  return sumfx /sumf\n  \n def variance(self):\n  m=self.mean()\n  sumfx2=sum(x *x *f for (x,f)in zip(self.midpoints,self.frequencies[:-1]))\n  sumf=sum(self.frequencies)\n  return sumfx2 /sumf -m *m\n  \nclass GroupedFrequencyDataDict(dict):\n def __init__(self,valueslabel,datadict=None ,rawdatadict=None ,boundaries=None ,classwidth=None ):\n  if rawdatadict:\n   gfdd={}\n   for key,rawdata in rawdatadict.items():\n    gfdd[key]=GroupedFrequencyData(valueslabel,rawdata=rawdata,boundaries=boundaries,classwidth=classwidth)\n  else :\n   gfdd={key:GroupedFrequencyData(valueslabel,gfd)for key,gfd in datadict.items()}\n  super().__init__(gfdd)\n  self.xMin=min(gfd.xMin for gfd in self.values())\n  self.xMax=max(gfd.xMax for gfd in self.values())\n  self.maxFrequency=max(gfd.maxFrequency for gfd in self.values())\n  self.maxFrequencyDensity=max(gfd.maxFrequencyDensity for gfd in self.values())\n  self.valuesLabel=valueslabel\n  \nclass CumulativeFrequencyData(list):\n def __init__(self,valueslabel,cumfreqdata=None ,groupedfreqdata=None ,rawdata=None ,boundaries=None ,classwidth=None ):\n  if rawdata:\n   groupedfreqdata=GroupedFrequencyData(valueslabel=valueslabel,rawdata=rawdata,boundaries=boundaries,classwidth=classwidth)\n  if groupedfreqdata:\n   cumfreqdata=self.fromGFD(groupedfreqdata)\n  else :\n   (b,f)=cumfreqdata[0]\n   if f !=0:cumfreqdata.insert(0,(2 *b -cft[1][0],0))\n  super().__init__(cumfreqdata)\n  self.boundaries=[item[0]for item in cumfreqdata]\n  self.cumfrequencies=[item[1]for item in cumfreqdata]\n  self.xMin,self.xMax=self.boundaries[0],self.boundaries[-1]\n  self.totalFrequency=self.cumfrequencies[-1]\n  self.valuesLabel=valueslabel\n  \n def fromGFD(self,groupedfreqdata):\n  (b,f)=groupedfreqdata[-1]\n  if f !=0:groupedfreqdata.append((2 *b -groupedfreqdata[-2][0],0))\n  L=len(groupedfreqdata)\n  boundaries,frequencies=zip(*groupedfreqdata)\n  cumfrequencies=[0]*L\n  for i in range(1,L):\n   cumfrequencies[i]=cumfrequencies[i -1]+frequencies[i -1]\n  return list(zip(boundaries,cumfrequencies))\n  \nclass CumulativeFrequencyDataDict(dict):\n def __init__(self,valueslabel,cfdatadict=None ,gfdatadict=None ,rawdatadict=None ,boundaries=None ,classwidth=None ):\n  if rawdatadict:\n   cfdd={}\n   for key,rawdata in rawdatadict.items():\n    cfdd[key]=CumulativeFrequencyData(valueslabel,rawdata=rawdata,boundaries=boundaries,classwidth=classwidth)\n  elif gfdatadict:\n   cfdd={key:CumulativeFrequencyData(valueslabel,groupedfreqdata=gfd)for key,gfd in gfdatadict.items()}\n  else :\n   cfdd={key:CumulativeFrequencyData(valueslabel,cfd)for key,cfd in cfdatadict.items()}\n  super().__init__(cfdd)\n  self.xMin=min(cfd.xMin for cfd in self.values())\n  self.xMax=max(cfd.xMax for cfd in self.values())\n  self.maxTotalFrequency=max(cfd.totalFrequency for cfd in self.values())\n  self.valuesLabel=valueslabel\n  \n  \n  \nclass PieChart(SVG.CanvasObject):\n def __init__(self,parent,data,title=\"\",colours=None ,usekey=True ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  super().__init__(width,height,objid=objid)\n  parent <=self\n  self.tooltips=[]\n  if not colours:colours=DEFAULT_COLOURS\n  if not usekey:\n   D=data.items()\n   n=len(D)\n   L=sorted(D,key=lambda x:x[1])\n   M=[]\n   for pair in zip(L[n //2:],L[:n //2]):M.extend(pair)\n   if n %2 ==1:M.append(L[-1])\n   data=LabelledData(M,data.valuesLabel)\n  angles=[0]\n  for percentage in data.percentages:\n   angles.append(angles[-1]+percentage *3.6)\n  self.sectors=[PieChartSector(self,(0,0),100,angles[i],angles[i+1],data.labels[i],data.Values[i],data.percentages[i],colours[i])for i in range(len(angles)-1)]\n  self.addObjects(self.sectors)\n  self.fitContents()\n  self.mouseMode=SVG.MouseMode.PAN\n  self.bind(\"touchstart\",self.clearTooltips)\n  \n  if usekey:\n   keysize=fontsize *1.25\n   keypos=SVG.Point((140,-len(data.labels)*keysize /2))\n   for i,label in enumerate(data.labels):\n    self.addObject(SVG.GroupObject([\n    SVG.RectangleObject([keypos,keypos+(fontsize,fontsize)],fillcolour=colours[i]),\n    SVG.TextObject(label,keypos+(keysize,fontsize /2),anchorposition=4,fontsize=fontsize)\n    ]))\n    keypos +=(0,keysize)\n   titlepos=(120,-110)\n  else :\n   anchorpositions=[7,4,1,3,6,9]\n   for i,label in enumerate(data.labels):\n    anglepos=(angles[i]+angles[i+1])/2\n    anchorposition=anchorpositions[int(anglepos //60)]\n    anchorpoint=(105 *sin(anglepos *pi /180),-105 *cos(anglepos *pi /180))\n    self.addObject(SVG.TextObject(label,anchorpoint,anchorposition,fontsize=fontsize))\n   titlepos=(0,-130)\n  if title:self.addObject(SVG.TextObject(title,titlepos,anchorposition=8,fontsize=fontsize *1.25))\n  self.fitContents()\n  \n def clearTooltips(self,event):\n  if event.target !=self:return\n  for tooltip in self.tooltips:tooltip.hide()\n  \nclass BarChart(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",direction=\"vertical\",colour=\"yellow\",fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  xaxis=bryaxes.Axis(0,100 *len(data),label=None ,showScale=False ,\n  showMajorTicks=False ,showMinorTicks=False ,showMajorGrid=False ,showMinorGrid=False )\n  yaxis=bryaxes.Axis(0,data.maxValue,data.valuesLabel)\n  if direction ==\"horizontal\":xaxis,yaxis=yaxis,xaxis\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  self.attachObject(Bars(self,data,direction=direction,colour=colour))\n  for i in range(len(data)):\n   if direction ==\"horizontal\":\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(-10 *self.xScaleFactor,i *100+60),80,anchorposition=6,fontsize=fontsize)\n   else :\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(i *100+60,0),80,fontsize=fontsize)\n   self.attachObject(label)\n  self.fitContents()\n  \nclass StackedBarChart(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",direction=\"vertical\",colours=None ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  if not colours:colours=DEFAULT_COLOURS\n  xaxis=bryaxes.Axis(0,100 *len(data.labels),label=\"\",showScale=False ,\n  showMajorTicks=False ,showMinorTicks=False ,showMajorGrid=False ,showMinorGrid=False )\n  yaxis=bryaxes.Axis(0,data.maxSum,data.valuesLabel)\n  if direction ==\"horizontal\":xaxis,yaxis=yaxis,xaxis\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  for i,key in enumerate(data.keys()):\n   self.attachObject(Bars(self,data,\"stacked\",i,key,direction,colours[i]))\n  for i in range(len(data.labels)):\n   if direction ==\"horizontal\":\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(-10 *self.xScaleFactor,i *100+60),80,anchorposition=6,fontsize=fontsize)\n   else :\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(i *100+60,0),80,fontsize=fontsize)\n   self.attachObject(label)\n  keywidth=20 *self.xScaleFactor\n  keyheight=fontsize *2 *self.yScaleFactor\n  keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.min+keyheight))\n  for i,key in enumerate(data.keys()):\n   self.attachObject(SVG.GroupObject([\n   SVG.RectangleObject([keypos,keypos+(keywidth,keyheight /2)],fillcolour=colours[i]),\n   bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=7,fontsize=fontsize)\n   ]))\n   keypos +=(0,keyheight)\n  self.fitContents()\n  \nclass GroupedBarChart(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",direction=\"vertical\",colours=None ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  if not colours:colours=DEFAULT_COLOURS\n  xaxis=bryaxes.Axis(0,100 *len(data.labels),label=\"\",showScale=False ,\n  showMajorTicks=False ,showMinorTicks=False ,showMajorGrid=False ,showMinorGrid=False )\n  yaxis=bryaxes.Axis(0,data.maxValue,data.valuesLabel)\n  if direction ==\"horizontal\":xaxis,yaxis=yaxis,xaxis\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  for i,key in enumerate(data.keys()):\n   self.attachObject(Bars(self,data,\"grouped\",i,key,direction,colours[i]))\n  for i in range(len(data.labels)):\n   if direction ==\"horizontal\":\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(-10 *self.xScaleFactor,i *100+60),80,anchorposition=6,fontsize=fontsize)\n   else :\n    label=bryaxes.AxesWrappingTextObject(self,data.labels[i],(i *100+60,0),80,fontsize=fontsize)\n   self.attachObject(label)\n  keywidth=20 *self.xScaleFactor\n  keyheight=fontsize *2 *self.yScaleFactor\n  keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.min+keyheight))\n  for i,key in enumerate(data.keys()):\n   self.attachObject(SVG.GroupObject([\n   SVG.RectangleObject([keypos,keypos+(keywidth,keyheight /2)],fillcolour=colours[i]),\n   bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=7,fontsize=fontsize)\n   ]))\n   keypos +=(0,keyheight)\n  self.fitContents()\n  \nclass ScatterGraph(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colour=\"red\",showregressionline=False ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.xLabel,showMajorGrid=True ,showMinorGrid=True )\n  yaxis=bryaxes.Axis(data.yMin,data.yMax,data.yLabel,showMajorGrid=True ,showMinorGrid=True )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  if isinstance(data,LabelledPairedData):\n   self.dataPoints=[DataPoint(self,label,coords,colour)for (label,coords)in data.items()]\n  else :\n   self.dataPoints=[DataPoint(self,None ,coords,colour)for coords in data]\n  self.attachObjects(self.dataPoints)\n  if showregressionline:\n   self.regressionLine=RegressionLine(data)\n   self.attachObject(self.regressionLine)\n   \nclass MultiScatterGraph(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colours=None ,showregressionlines=False ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.xLabel,showMajorGrid=True ,showMinorGrid=True )\n  yaxis=bryaxes.Axis(data.yMin,data.yMax,data.yLabel,showMajorGrid=True ,showMinorGrid=True )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  if not colours:colours=DEFAULT_COLOURS\n  if showregressionlines ==True :showregressionlines=[True ]*len(data)\n  if showregressionlines ==False :showregressionlines=[False ]*len(data)\n  for i,(key,dataset)in enumerate(data.items()):\n   if isinstance(dataset,LabelledPairedData):\n    self.dataPoints=[DataPoint(self,label,coords,colours[i])for (label,coords)in dataset.items()]\n   else :\n    self.dataPoints=[DataPoint(self,None ,coords,colours[i])for coords in dataset]\n   self.attachObjects(self.dataPoints)\n   if showregressionlines[i]:\n    self.regressionLine=RegressionLine(dataset,colours[i])\n    self.attachObject(self.regressionLine)\n  keywidth=20 *self.xScaleFactor\n  keyheight=fontsize *2 *self.yScaleFactor\n  keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.min+keyheight))\n  for i,key in enumerate(data.keys()):\n   self.attachObject(SVG.GroupObject([\n   SVG.EllipseObject(pointlist=[keypos,keypos+(keywidth,keyheight /2)],fillcolour=colours[i]),\n   bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=7,fontsize=fontsize)\n   ]))\n   keypos +=(0,keyheight)\n  self.fitContents()\n  \nclass LineGraph(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colours=None ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.xLabel,showMajorGrid=True ,showMinorGrid=True )\n  yaxis=bryaxes.Axis(data.yMin,data.yMax,data.yLabel,showMajorGrid=True ,showMinorGrid=True )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  if not colours:colours=DEFAULT_COLOURS\n  if isinstance(data,PairedData):\n   self.attachObject(SVG.PolylineObject(data,linecolour=colours[0]))\n  else :\n   keywidth=20 *self.xScaleFactor\n   keyheight=fontsize *2 *self.yScaleFactor\n   keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.max))\n   keydata=[]\n   for i,(key,pd)in enumerate(data.items()):\n    self.attachObject(SVG.PolylineObject(pd,linecolour=colours[i],linewidth=2))\n    self.attachObjects([DataPoint(self,key,coords,colours[i])for coords in pd])\n    keydata.append((pd.yValues[-1],key,colours[i]))\n   keydata.sort(key=lambda x:-x[0])\n   for (_,key,colour)in keydata:\n    self.attachObject(SVG.GroupObject([\n    SVG.LineObject([keypos,keypos+(keywidth,0)],linecolour=colour,linewidth=2),\n    bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=4,fontsize=fontsize)\n    ]))\n    keypos +=(0,-keyheight)\n   self.fitContents()\n   \nclass BoxPlotCanvas(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colour=\"yellow\",fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  if isinstance(data,BoxPlotData):data=BoxPlotDataDict(data.valuesLabel,{\"\":data})\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.valuesLabel)\n  yaxis=bryaxes.Axis(0,50 *len(data),\"\",showAxis=False ,showMajorTicks=False ,showMinorTicks=False )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  self.fitContents()\n  yheight=25\n  for label,boxplotdata in data.items():\n   self.attachObject(BoxPlot(boxplotdata,label,yheight,colour))\n   if label:self.attachObject(bryaxes.AxesWrappingTextObject(self,label,(xaxis.min -10 *self.xScaleFactor,yheight),100,6,fontsize))\n   yheight +=50\n  self.fitContents()\n  \nclass Histogram(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",shownormalcurve=False ,colour=\"yellow\",fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.valuesLabel)\n  yaxis=bryaxes.Axis(0,data.maxFrequencyDensity,\"Frequency density\")\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  self.attachObject(HistogramBars(data,colour))\n  if shownormalcurve:\n   self.attachObject(NormalCurve(data))\n   \nclass CumulativeFrequencyGraph(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colours=None ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  if isinstance(data,CumulativeFrequencyData):data=CumulativeFrequencyDataDict(data.valuesLabel,{\"\":data})\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.valuesLabel,showMajorGrid=True ,showMinorGrid=True )\n  yaxis=bryaxes.Axis(0,data.maxTotalFrequency,\"Cumulative frequency\",showMajorGrid=True ,showMinorGrid=True )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  if not colours:colours=DEFAULT_COLOURS\n  for i,(key,cfd)in enumerate(data.items()):\n   self.attachObject(CumulativeFrequencyLine(key,cfd,colours[i]))\n  if len(data)>1:\n   keywidth=20 *self.xScaleFactor\n   keyheight=fontsize *2 *self.yScaleFactor\n   keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.max))\n   for i,key in enumerate(data.keys()):\n    self.attachObject(SVG.GroupObject([\n    SVG.LineObject([keypos,keypos+(keywidth,0)],linecolour=colours[i],linewidth=2),\n    bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=4,fontsize=fontsize)\n    ]))\n    keypos +=(0,-keyheight)\n   self.fitContents()\n   \nclass CumulativePercentageGraph(bryaxes.AxesCanvas):\n def __init__(self,parent,data,title=\"\",colours=None ,fontsize=14,width=\"95%\",height=\"95%\",objid=None ):\n  if isinstance(data,CumulativeFrequencyData):data=CumulativeFrequencyDataDict(data.valuesLabel,{\"\":data})\n  xaxis=bryaxes.Axis(data.xMin,data.xMax,data.valuesLabel,showMajorGrid=True ,showMinorGrid=True )\n  yaxis=bryaxes.Axis(0,100,\"Cumulative percentage\",showMajorGrid=True ,showMinorGrid=True )\n  super().__init__(parent,width,height,xAxis=xaxis,yAxis=yaxis,title=title,objid=objid)\n  if not colours:colours=DEFAULT_COLOURS\n  for i,(key,cfd)in enumerate(data.items()):\n   self.attachObject(CumulativePercentageLine(key,cfd,colours[i]))\n  if len(data)>1:\n   keywidth=20 *self.xScaleFactor\n   keyheight=fontsize *2 *self.yScaleFactor\n   keypos=SVG.Point((self.xAxis.max+keywidth,self.yAxis.max))\n   for i,key in enumerate(data.keys()):\n    self.attachObject(SVG.GroupObject([\n    SVG.LineObject([keypos,keypos+(keywidth,0)],linecolour=colours[i],linewidth=2),\n    bryaxes.AxesTextObject(self,key,keypos+(keywidth *1.25,0),anchorposition=4,fontsize=fontsize)\n    ]))\n    keypos +=(0,-keyheight)\n   self.fitContents()\n   \n   \n   \nclass PieChartSector(SVG.SectorObject):\n def __init__(self,canvas,centre,radius,startangle,endangle,label,value,percentage,colour):\n  super().__init__(centre,radius,startangle,endangle,fillcolour=colour)\n  self.canvas=canvas\n  self.centre=(self.pointList[0]+self.pointList[1]+self.pointList[2])/3\n  self.tooltiptext=f\"{label}\\n{value} ({percentage:.2f}%)\"\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  self.tooltip=Tooltip(self.canvas,self.tooltiptext,self.centre)\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass Tooltip(SVG.TextObject):\n def __init__(self,canvas,text,coords):\n  super().__init__(text,coords,anchorposition=5)\n  self.canvas=canvas\n  self.coords=coords\n  self._background=None\n  self.style.pointerEvents=\"none\"\n  self.canvas.addObject(self)\n  self.setBackground()\n  self.canvas <=self\n  self.canvas.tooltips.append(self)\n  \n def setBackground(self):\n  bbox=self.getBBox()\n  width,height=bbox.width,bbox.height\n  x,y=self.coords\n  self._background=SVG.RectangleObject([(x -width /2,y -height /2),(x+width /2,y+height /2)],linecolour=\"#d3d3d3d0\",fillcolour=\"#d3d3d3d0\")\n  self.canvas.addObject(self._background)\n  self._background.style.pointerEvents=\"none\"\n  \n def hide(self):\n  self.canvas.deleteObject(self._background)\n  self.canvas.deleteObject(self)\n  \nclass AxesTooltip(bryaxes.AxesTextObject):\n def __init__(self,canvas,text,coords):\n  super().__init__(canvas,text,coords,anchorposition=8)\n  self.canvas=canvas\n  self.coords=coords\n  self._background=None\n  self.style.pointerEvents=\"none\"\n  self.canvas.attachObject(self)\n  self.setBackground()\n  self.canvas.container <=self\n  self.canvas.tooltips.append(self)\n  \n def setBackground(self):\n  bbox=self.getBBox()\n  width,height=bbox.width *self.canvas.xScaleFactor,bbox.height *self.canvas.yScaleFactor\n  x,y=self.coords\n  self._background=SVG.RectangleObject([(x -width /2,y+height),(x+width /2,y)],linecolour=\"#d3d3d3d0\",fillcolour=\"#d3d3d3d0\")\n  self.canvas.attachObject(self._background)\n  self._background.style.pointerEvents=\"none\"\n  \n def hide(self):\n  self.canvas.container.removeObject(self._background)\n  self.canvas.container.removeObject(self)\n  \nclass Bar(SVG.RectangleObject):\n def __init__(self,canvas,pointlist,key,value,direction=\"vertical\",colour=\"yellow\"):\n  if direction ==\"horizontal\":pointlist=[(y,x)for (x,y)in pointlist]\n  super().__init__(pointlist,fillcolour=colour)\n  self.canvas=canvas\n  self.tooltiptext=f\"{key}\\n{value}\"if key else f\"{value}\"\n  self.centre=(self.pointList[0]+self.pointList[1])/2\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,self.centre)\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass Bars(SVG.GroupObject):\n def __init__(self,canvas,data,graphtype=None ,index=None ,key=None ,direction=\"vertical\",colour=\"yellow\"):\n  super().__init__()\n  if graphtype ==\"stacked\":\n   barminvalues=[sums[index]for sums in data.sums.values()]\n   barmaxvalues=[sums[index+1]for sums in data.sums.values()]\n   barwidth=80\n   offset=20\n  elif graphtype ==\"grouped\":\n   barminvalues=[0]*len(data.labels)\n   barmaxvalues=[values[index]for values in data.Values.values()]\n   barwidth=80 /len(data)\n   offset=20+barwidth *index\n  else :\n   barminvalues=[0]*len(data)\n   barmaxvalues=data.Values\n   barwidth=80\n   offset=20\n   \n  for i,label in enumerate(data.labels):\n   [barstart,barend]=[i *100+offset,i *100+offset+barwidth]\n   value=data.Values[label][index]if key else data.Values[i]\n   if value >0:\n    self.addObject(Bar(canvas,[(barstart,barmaxvalues[i]),(barend,barminvalues[i])],key,value,direction,colour))\n    \nclass DataPoint(bryaxes.AxesPoint):\n def __init__(self,canvas,label,coords,colour=\"red\",objid=None ):\n  super().__init__(canvas,coords,colour)\n  self.canvas=canvas\n  self.coords=coords\n  self.tooltiptext=f\"{label}\\n{coords}\"if label else f\"{coords}\"\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,self.coords)\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass RegressionLine(SVG.LineObject):\n def __init__(self,data,colour=\"black\"):\n  points=data.values()if isinstance(data,LabelledPairedData)else data\n  pmcc,gradient,yintercept=regressioninfo(points)\n  sign=\"\"if yintercept <0 else \"+\"\n  n1=2 -int(log10(gradient))\n  n2=2 -int(log10(yintercept))\n  self.tooltiptext=f\"y = {gradient:.{n1}f}x{sign}{yintercept:.{n2}f}\\n(PMCC = {pmcc:.2f})\"\n  x1,x2=data.xMin,data.xMax\n  y1,y2=gradient *x1+yintercept,gradient *x2+yintercept\n  super().__init__([(x1,y1),(x2,y2)],linecolour=colour,linewidth=2)\n  \n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  (x,y)=self.canvas.getSVGcoords(event)\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,(x,-y))\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass BoxPlot(SVG.GroupObject):\n def __init__(self,boxplotinfo,label,yheight,colour=\"yellow\"):\n  xmin,Q1,Q2,Q3,xmax=boxplotinfo\n  super().__init__([\n  SVG.LineObject([(xmin,yheight -5),(xmin,yheight+5)]),\n  SVG.LineObject([(xmin,yheight),(Q1,yheight)]),\n  SVG.RectangleObject([(Q1,yheight -15),(Q2,yheight+15)],fillcolour=colour),\n  SVG.RectangleObject([(Q2,yheight -15),(Q3,yheight+15)],fillcolour=colour),\n  SVG.LineObject([(Q3,yheight),(xmax,yheight)]),\n  SVG.LineObject([(xmax,yheight -5),(xmax,yheight+5)])\n  ])\n  self.tooltiptext=f\"{label}\\nMin={xmin}, Q1={Q1}, Q2={Q2}, Q3={Q3}, Max={xmax}\"\n  self.centre=((Q1+Q2)/2,yheight)\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,self.centre)\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass HistogramBar(SVG.RectangleObject):\n def __init__(self,gfd,i,colour=\"yellow\"):\n  [barleft,barright]=gfd.boundaries[i:i+2]\n  super().__init__([(barleft,gfd.frequencyDensities[i]),(barright,0)],fillcolour=colour)\n  self.tooltiptext=f\"{barleft}\u2264x<{barright}\\nFrequency: {gfd.frequencies[i]}\\nFrequency Density: {gfd.frequencyDensities[i]}\"\n  self.centre=((barleft+barright)/2,gfd.frequencyDensities[i]/2)\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,self.centre)\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass HistogramBars(SVG.GroupObject):\n def __init__(self,gfd,colour=\"yellow\"):\n  super().__init__()\n  for i in range(len(gfd)-1):\n   self.addObject(HistogramBar(gfd,i,colour))\n   \nclass NormalCurve(SVG.PolylineObject):\n def __init__(self,gfd):\n  m=gfd.mean()\n  v=gfd.variance()\n  s=v **0.5\n  k=sum(gfd.frequencies)/(s *(2 *pi)**0.5)\n  x0=gfd.xMin\n  dx=(gfd.xMax -x0)/200\n  points=[(x0+i *dx,k *exp(-0.5 *(((x0+i *dx)-m)/s)**2))for i in range(201)]\n  super().__init__(points,linewidth=2)\n  self.tooltiptext=f\"\u00b5 = {m:.1f}\\n\u03c3\u00b2 = {v:.1f}\"\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  (x,y)=self.canvas.getSVGcoords(event)\n  self.tooltip=AxesTooltip(self.canvas,self.tooltiptext,(x,-y))\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \n  \nclass CumulativeFrequencyLine(SVG.PolylineObject):\n def __init__(self,key,cfd,colour):\n  super().__init__(cfd,linecolour=colour,linewidth=2)\n  self.key=key\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  (x,y)=self.canvas.getSVGcoords(event)\n  n=int(3 -log10(x))\n  tooltiptext=f\"{self.key}\\nNumber of values < {x:.{n}f}: {-y:.0f}\"\n  self.tooltip=AxesTooltip(self.canvas,tooltiptext,(x,-y))\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass CumulativePercentageLine(SVG.PolylineObject):\n def __init__(self,key,cfd,colour):\n  total=cfd.totalFrequency\n  points=[(x,100 *y /total)for (x,y)in cfd]\n  super().__init__(points,linecolour=colour,linewidth=2)\n  self.key=key\n  self.bind(\"mouseenter\",self.showtooltip)\n  self.bind(\"touchstart\",self.showtooltip)\n  self.bind(\"mouseleave\",self.hidetooltip)\n  \n def showtooltip(self,event):\n  for tooltip in self.canvas.tooltips:tooltip.hide()\n  (x,y)=self.canvas.getSVGcoords(event)\n  n=int(3 -log10(x))\n  tooltiptext=f\"{self.key}\\n%age of values < {x:.{n}f}: {-y:.0f}%\"\n  self.tooltip=AxesTooltip(self.canvas,tooltiptext,(x,-y))\n  \n def hidetooltip(self,event):\n  self.tooltip.hide()\n  \nclass DataTable(list):\n def __init__(self,csvfile=None ,datasets=\"columns\",headers=True ):\n  if csvfile:\n   with open(csvfile)as datafile:\n    lines=datafile.readlines()\n   data=[line.strip().split(\",\")for line in lines]\n   data=[[convertifnumber(item)for item in row]for row in data]\n  fieldnames=data[0]\n  super().__init__([{key:value for key,value in zip(fieldnames,data[i])}for i in range(1,len(data))])\n", ["brycharts", "brycharts.roundfns", "brycharts.statfns", "collections", "math"]], "brycharts.roundfns": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nimport math\n\ndef sign(X):\n return math.copysign(1,X)\n \ndef roundUp(X,n):\n nn=math.copysign(10,X)if abs(n)>10 else n\n p=10 **nn\n return int(X *p+1)/p\n \ndef roundDown(X,n):\n nn=math.copysign(10,X)if abs(n)>10 else n\n p=10 **nn\n return int(X *p)/p\n \ndef rounddown(x,n):\n return math.floor(x /n)*n\n \ndef roundup(x,n):\n return math.ceil(x /n)*n\n \ndef roundscale(interval,mindivs):\n if interval ==0:return 1\n if mindivs <2:return interval\n X=interval /(mindivs -1)\n L=10 **math.floor(math.log10(X))\n xx=X /L\n Y=1 if xx <=2 else 2 if xx <=5 else 5 if xx <=10 else 10\n return Y *L,Y\n \ndef getscaleintervals(xmin,xmax,mindivs):\n interval=xmax -xmin\n if interval ==0:return 1,1,1\n if mindivs <2:return interval,interval,interval\n X=interval /(mindivs -1)\n L=10 **math.floor(math.log10(X))\n xx=X /L\n Y=1 if xx <=2 else 2 if xx <=5 else 5 if xx <=10 else 10\n scaleinterval=Y *L\n if Y in {1,10}:\n  majorinterval=scaleinterval /2.0\n  minorinterval=scaleinterval /10.0\n elif Y ==5:\n  majorinterval=scaleinterval\n  minorinterval=scaleinterval /5.0\n elif Y ==2:\n  majorinterval=scaleinterval /2.0\n  minorinterval=scaleinterval /10.0\n return scaleinterval,majorinterval,minorinterval\n \ndef roundsf2(X,n):\n if X ==0:\n  return 0\n else :\n  L=float(10)**math.floor(math.log10(abs(X)))\n  xx=X /L\n  return round(xx,n -1)*L\n  \ndef roundsf(x,sf=3):\n if x ==0:return 0\n xx=-x if x <0 else x\n return round(x,sf -int(math.floor(math.log10(xx)))-1)\n \ndef linintx(ycoord,point1,point2):\n (x1,y1)=point1\n (x2,y2)=point2\n return (x1+(ycoord -y1)*(x2 -x1)/(y2 -y1),ycoord)\n \ndef lininty(xcoord,point1,point2):\n (x1,y1)=point1\n (x2,y2)=point2\n return (xcoord,y1+(xcoord -x1)*(y2 -y1)/(x2 -x1))\n \nif __name__ ==\"__main__\":\n for interval,mindivs in [(100,5),(100,6),(273,7),(97,6)]:\n  print(interval,mindivs,roundscale(interval,mindivs))\n", ["math"]]}
__BRYTHON__.update_VFS(scripts)
